{"version":3,"sources":["cdp:///@cdp/framework-core/core-utils/config.ts","cdp:///@cdp/framework-core/core-utils/types.ts","cdp:///@cdp/framework-core/core-utils/verify.ts","cdp:///@cdp/framework-core/core-utils/deep-circuit.ts","cdp:///@cdp/framework-core/core-utils/mixins.ts","cdp:///@cdp/framework-core/core-utils/array.ts","cdp:///@cdp/framework-core/core-utils/safe.ts","cdp:///@cdp/framework-core/core-utils/timer.ts","cdp:///@cdp/framework-core/core-utils/misc.ts","cdp:///@cdp/framework-core/event-publisher/publisher.ts","cdp:///@cdp/framework-core/event-publisher/broker.ts","cdp:///@cdp/framework-core/promise/internal.ts","cdp:///@cdp/framework-core/promise/cancel-token.ts","cdp:///@cdp/framework-core/promise/cancelable-promise.ts","cdp:///@cdp/framework-core/promise/utils.ts","cdp:///@cdp/framework-core/observable/internal.ts","cdp:///@cdp/framework-core/observable/object.ts","cdp:///@cdp/framework-core/observable/array.ts","cdp:///@cdp/framework-core/core-storage/memory-storage.ts","cdp:///@cdp/framework-core/result/result-code-defs.ts","cdp:///@cdp/framework-core/result/result-code.ts","cdp:///@cdp/framework-core/result/result.ts","cdp:///@cdp/framework-core/core-storage/registry.ts","cdp:///@cdp/framework-core/observable/common.ts"],"names":["getGlobal","globalThis","Function","getConfig","root","CDP","Config","exists","x","isNil","isString","isNumber","isSymbol","isArray","Array","isObject","Boolean","isPlainObject","Object","getPrototypeOf","ownInstanceOf","isEmptyObject","name","isFunction","isIterable","Symbol","iterator","_typedArrayNames","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","isTypedArray","className","ctor","prototype","toStringTagName","toStringTag","constructor","toString","call","slice","sameClass","lhs","rhs","_verifier","notNil","message","TypeError","typeOf","type","array","iterable","instanceOf","notOwnInstanceOf","hasProperty","prop","String","hasOwnProperty","verify","method","args","arrayEqual","len","length","i","deepEqual","bufferEqual","size","byteLength","pos","f64L","f64R","is","L","DataView","R","getUint32","getUint16","getUint8","valueL","valueOf","valueR","isRegExpL","RegExp","isRegExpR","isArrayL","isArrayR","isBufferL","ArrayBuffer","isBufferR","isBufferViewL","isView","isBufferViewR","buffer","isIterableL","isIterableR","keysL","Set","keys","keysR","key","has","add","cloneArrayBuffer","arrayBuffer","result","set","merge","target","source","undefined","cloneRegExp","regexp","flags","lastIndex","cloneTypedArray","typedArray","byteOffset","cloneDataView","dataView","mergeArray","oldValue","newValue","mergeSet","item","Map","mergeMap","k","v","get","obj","deepMerge","sources","deepCopy","src","_objPrototype","_instanceOf","hasInstance","_override","_isInherited","_constructors","_classBase","_classSources","_protoExtendsOnly","copyProperties","getOwnPropertyNames","filter","test","forEach","defineProperty","getOwnPropertyDescriptor","setInstanceOf","behaviour","isPrototypeOf","applied","defineProperties","[object Object]","value","writable","enumerable","random","Math","bind","async","map","callback","thisArg","Promise","all","a","this","accessible","Proxy","callable","safe","create","stub","_setTimeout","setTimeout","_clearTimeout","clearTimeout","_setInterval","setInterval","_clearInterval","clearInterval","post","executor","resolve","then","createEscaper","escaper","match","join","regexTest","regexReplace","replace","escapeHTML","<",">","&","\"","'","`","fromTypedData","data","JSON","stringify","dropUndefined","nilSerialize","restoreNil","capitalize","lowercaseRest","remainingChars","toLowerCase","charAt","toUpperCase","decapitalize","camelize","lower","trim","c","_mapListeners","WeakMap","listeners","instance","validChannel","channel","validListener","listener","EventPublisher","list","handled","e","reject","clear","channels","ch","delete","freeze","enable","unsubscribe","context","on","managed","EventBroker","_cancel","_close","invalidSubscription","_tokens","getContext","CancelToken","linkedTokens","cancel","close","token","onCancel","onClose","linkedTokenSet","t","status","publisher","subscriptions","reason","seal","register","cancelable","requested","closed","s","publish","off","NativePromise","_create","CancelablePromise","static","species","cancelToken","super","thenArgs","p","dispose","Error","apply","setPrototypeOf","onfulfilled","onrejected","onfinally","finally","extendPromise","wait","promises","safePromises","promise","catch","checkCanceled","noAutomaticNativeExtend","_regexCancelLikeString","EventBrokerProxy","_broker","_internal","_notify","_stockChange","_notifyChanges","verifyObservable","_proxyHandler","receiver","Reflect","state","ObservableObject","internal","changeMap","broker","property","props","noRecord","observable","resume","properties","keyValue","keyValuePairs","curValue","values","attributes","byMethod","oldLength","newLength","stock","scrap","isValidArrayIndex","Number","deleteProperty","index","n","trunc","ObservableArray","arguments","records","indexes","argLength","comparator","old","from","sort","start","deleteCount","items","oldLen","splice","max","min","shift","unshift","callbackfn","rci","findRelatedChangeIndex","checkType","rct","r","prevRecord","MemoryStorage","_storage","kind","options","cc","dataType","newVal","oldVal","silent","memoryStorage","CDP_DECLARE","RESULT_CODE","ASSIGN_RESULT_CODE","extend","assign","_code2message","0","1","2","3","-1","-2","-3","declareResultCode","base","code","succeeded","RangeError","signed","resultCode","ERROR_MESSAGE_MAP","DECLARE_SUCCESS_CODE","DECLARE_ERROR_CODE","FAILED","SUCCEEDED","toNameString","tag","prefix","toHelpString","isFinite","Result","cause","SUCCESS","FAIL","time","isError","Date","now","descriptors","isSucceeded","isFailed","isCanceled","ABORT","codeName","help","PromiseManager","_pool","cancelSource","always","race","canceler","Registry","storage","rootKey","formatSpace","_store","_rootKey","_defaultOptions","jsonSpace","getItem","opts","setItem","field","structure","split","lastKey","pop","reg","_targetRoot","noSave","remove","write","removeItem","classify","dasherize","every","entries","bits","find","findIndex","groupBy","sumKeys","groupKey","_groupKey","_sumKeys","push","hash","reduce","res","_key","keyList","h","resKey","indices","excludes","retval","exList","ex","isBoolean","isChancelLikeError","error","isObservable","isPrimitive","isResult","makeCanceledResult","makeResult","mixins","_hasSourceConstructor","_MixinBase","constructors","srcClass","handler","thisobj","arglist","ctors","desc","orgInstanceOf","inst","parent","noop","partialize","pickupKeys","initialValue","hasInit","acc","sameType","setMixClassAttribute","attr","shuffle","destructive","j","swap","sleep","elapse","some","concat","toResult","o","toTypedData","parse","underscored"],"mappings":"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","sourcesContent":["/**\n * @en Safe `global` accessor.\n * @ja `global` アクセッサ\n * \n * @returns\n *  - `en` `global` object of the runtime environment\n *  - `ja` 環境に応じた `global` オブジェクト\n */\nexport function getGlobal(): typeof globalThis {\n    // eslint-disable-next-line no-new-func\n    return ('object' === typeof globalThis) ? globalThis : Function('return this')();\n}\n\n/**\n * @en Global config accessor.\n * @ja グローバルコンフィグアクセッサ\n */\nexport function getConfig<T extends {} = {}>(): T {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const root: any = getGlobal();\n    if (!root.CDP || !root.CDP.Config) {\n        root.CDP = root.CDP || {};\n        root.CDP.Config = root.Config || {};\n    }\n    return root.CDP.Config;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * @en The general null type.\n * @ja 空を示す型定義\n */\nexport type Nil = void | null | undefined;\n\n/**\n * @en The type of object or [[Nil]].\n * @ja [[Nil]] になりえるオブジェクト型定義\n */\nexport type Nillable<T extends {}> = T | Nil;\n\n/**\n * @en Primitive type of JavaScript.\n * @ja JavaScript のプリミティブ型\n */\nexport type Primitive = string | number | boolean | symbol | null | undefined;\n\n/**\n * @en JavaScript type set interface.\n * @ja JavaScript の型の集合\n */\ninterface TypeList {\n    string: string;\n    number: number;\n    boolean: boolean;\n    symbol: symbol;\n    undefined: void | undefined;\n    object: object | null;\n    function(...args: unknown[]): unknown;\n}\n\n/**\n * @en The key list of [[TypeList]].\n * @ja [[TypeList]] キー一覧\n */\nexport type TypeKeys = keyof TypeList;\n\n/**\n * @en Type base definition.\n * @ja 型の規定定義\n */\nexport interface Type<T extends {}> extends Function {\n    readonly prototype: T;\n}\n\n/**\n * @en Type of constructor.\n * @ja コンストラクタ型\n */\nexport interface Constructor<T> extends Type<T> {\n    new(...args: unknown[]): T;\n}\n\n/**\n * @en Type of class.\n * @ja クラス型\n */\nexport type Class<T = any> = Constructor<T>;\n\n/**\n * @en Ensure for function parameters to tuple.\n * @ja 関数パラメータとして tuple を保証\n */\nexport type Arguments<T> = T extends any[] ? T : [T];\n\n/**\n * @en Rmove `readonly` attributes from input type.\n * @ja `readonly` 属性を解除\n */\nexport type Writable<T> = { -readonly [K in keyof T]: T[K] };\n\n/**\n * @en Extract functional property names.\n * @ja 関数プロパティ名の抽出\n */\nexport type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n\n/**\n * @en Extract functional properties.\n * @ja 関数プロパティの抽出\n */\nexport type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\n/**\n * @en Extract non-functional property names.\n * @ja 非関数プロパティ名の抽出\n */\nexport type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\n\n/**\n * @en Extract non-functional properties.\n * @ja 非関数プロパティの抽出\n */\nexport type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\n/**\n * @en Extract object key list. (`keyof` alias)\n * @ja オブジェクトのキー一覧を抽出 (`keyof` alias)\n */\nexport type Keys<T extends {}> = keyof T;\n\n/**\n * @en Extract object type list.\n * @ja オブジェクトの型一覧を抽出\n */\nexport type Types<T extends {}> = T[keyof T];\n\n/**\n * @en Convert object key to type.\n * @ja オブジェクトキーから型へ変換\n */\nexport type KeyToType<O extends {}, K extends keyof O> = K extends keyof O ? O[K] : never;\n\n/**\n * @en Convert object type to key.\n * @ja オブジェクト型からキーへ変換\n */\nexport type TypeToKey<O extends {}, T extends Types<O>> = { [K in keyof O]: O[K] extends T ? K : never }[keyof O];\n\n/**\n * @en The [[PlainObject]] type is a JavaScript object containing zero or more key-value pairs. <br>\n *     'Plain' means it from other kinds of JavaScript objects. ex: null, user-defined arrays, and host objects such as `document`.\n * @ja 0 以上の key-value ペアを持つ [[PlainObject]] 定義 <br>The PlainObject type is a JavaScript object containing zero or more key-value pairs. <br>\n *     'Plain' とは他の種類の JavaScript オブジェクトを含まないオブジェクトを意味する. 例:  null, ユーザー定義配列, または `document` のような組み込みオブジェクト\n */\nexport interface PlainObject<T = any> {\n    [key: string]: T;\n}\n\n/**\n * @en The data type list by which style compulsion is possible.\n * @ja 型強制可能なデータ型一覧\n */\nexport type TypedData = string | number | boolean | null | object;\n\n/**\n * @en The data type list of TypedArray.\n * @ja TypedArray 一覧\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Check the value exists.\n * @ja 値が存在するか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function exists<O extends {}>(x: Nillable<O>): x is O;\nexport function exists(x: unknown): x is unknown;\nexport function exists(x: any): any {\n    return null != x;\n}\n\n/**\n * @en Check the value-type is [[Nil]].\n * @ja [[Nil]] 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isNil(x: unknown): x is Nil {\n    return null == x;\n}\n\n/**\n * @en Check the value-type is String.\n * @ja String 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isString(x: unknown): x is string {\n    return 'string' === typeof x;\n}\n\n/**\n * @en Check the value-type is Number.\n * @ja Number 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isNumber(x: unknown): x is number {\n    return 'number' === typeof x;\n}\n\n/**\n * @en Check the value-type is Boolean.\n * @ja Boolean 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isBoolean(x: unknown): x is boolean {\n    return 'boolean' === typeof x;\n}\n\n/**\n * @en Check the value-type is Symble.\n * @ja Symbol 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isSymbol(x: unknown): x is symbol {\n    return 'symbol' === typeof x;\n}\n\n/**\n * @en Check the value-type is primitive type.\n * @ja プリミティブ型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isPrimitive(x: unknown): x is Primitive {\n    return !x || ('function' !== typeof x) && ('object' !== typeof x);\n}\n\n/**\n * @en Check the value-type is Array.\n * @ja Array 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport const isArray = Array.isArray; // eslint-disable-line @typescript-eslint/unbound-method\n\n/**\n * @en Check the value-type is Object.\n * @ja Object 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isObject(x: unknown): x is object {\n    return Boolean(x) && 'object' === typeof x;\n}\n\n/**\n * @en Check the value-type is [[PlainObject]].\n * @ja [[PlainObject]] 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isPlainObject(x: unknown): x is PlainObject {\n    if (!isObject(x)) {\n        return false;\n    }\n\n    // create from `Object.create( null )` is plain\n    if (!Object.getPrototypeOf(x)) {\n        return true;\n    }\n\n    return ownInstanceOf(Object, x);\n}\n\n/**\n * @en Check the value-type is empty object.\n * @ja 空オブジェクトであるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isEmptyObject(x: unknown): x is object {\n    if (!isPlainObject(x)) {\n        return false;\n    }\n    for (const name in x) { // eslint-disable-line @typescript-eslint/no-unused-vars\n        return false;\n    }\n    return true;\n}\n\n/**\n * @en Check the value-type is Function.\n * @ja Function 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isFunction(x: unknown): x is TypeList['function'] {\n    return 'function' === typeof x;\n}\n\n/**\n * @en Check the value-type is input.\n * @ja 指定した型であるか判定\n *\n * @param type\n *  - `en` evaluated type\n *  - `ja` 評価する型\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function typeOf<K extends TypeKeys>(type: K, x: unknown): x is TypeList[K] {\n    return typeof x === type;\n}\n\n/**\n * @en Check the value has iterator.\n * @ja iterator を所有しているか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isIterable<T>(x: Nillable<Iterable<T>>): x is Iterable<T>;\nexport function isIterable(x: unknown): x is Iterable<unknown>;\nexport function isIterable(x: any): any {\n    return Symbol.iterator in Object(x);\n}\n\nconst _typedArrayNames = {\n    'Int8Array': true,\n    'Uint8Array': true,\n    'Uint8ClampedArray': true,\n    'Int16Array': true,\n    'Uint16Array': true,\n    'Int32Array': true,\n    'Uint32Array': true,\n    'Float32Array': true,\n    'Float64Array': true,\n};\n\n/**\n * @en Check the value is one of [[TypedArray]].\n * @ja 指定したインスタンスが [[TypedArray]] の一種であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isTypedArray(x: unknown): x is TypedArray {\n    return !!_typedArrayNames[className(x)];\n}\n\n/**\n * @en Check the value instance of input.\n * @ja 指定したインスタンスであるか判定\n *\n * @param ctor\n *  - `en` evaluated constructor\n *  - `ja` 評価するコンストラクタ\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function instanceOf<T extends {}>(ctor: Nillable<Type<T>>, x: unknown): x is T {\n    return ('function' === typeof ctor) && (x instanceof ctor);\n}\n\n/**\n * @en Check the value instance of input constructor (except sub class).\n * @ja 指定コンストラクタのインスタンスであるか判定 (派生クラスは含めない)\n *\n * @param ctor\n *  - `en` evaluated constructor\n *  - `ja` 評価するコンストラクタ\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function ownInstanceOf<T extends {}>(ctor: Nillable<Type<T>>, x: unknown): x is T {\n    return (null != x) && ('function' === typeof ctor) && (Object.getPrototypeOf(x) === Object(ctor.prototype));\n}\n\n/**\n * @en Get the value's class name.\n * @ja クラス名を取得\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function className(x: any): string {\n    if (x != null) {\n        const toStringTagName = x[Symbol.toStringTag];\n        if (isString(toStringTagName)) {\n            return toStringTagName;\n        } else if (isFunction(x) && x.prototype && null != x.name) {\n            return x.name;\n        } else {\n            const ctor = x.constructor;\n            if (isFunction(ctor) && ctor === (Object(ctor.prototype) as object).constructor) {\n                return ctor.name;\n            }\n        }\n    }\n    return (Object.prototype.toString.call(x) as string).slice(8, -1);\n}\n\n/**\n * @en Check input values are same value-type.\n * @ja 入力が同一型であるか判定\n *\n * @param lhs\n *  - `en` evaluated value\n *  - `ja` 評価する値\n * @param rhs\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function sameType(lhs: unknown, rhs: unknown): boolean {\n    return typeof lhs === typeof rhs;\n}\n\n/**\n * @en Check input values are same class.\n * @ja 入力が同一クラスであるか判定\n *\n * @param lhs\n *  - `en` evaluated value\n *  - `ja` 評価する値\n * @param rhs\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function sameClass(lhs: unknown, rhs: unknown): boolean {\n    if (null == lhs && null == rhs) {\n        return className(lhs) === className(rhs);\n    } else {\n        return (null != lhs) && (null != rhs) && (Object.getPrototypeOf(lhs) === Object.getPrototypeOf(rhs));\n    }\n}\n\n/**\n * @en Get shallow copy of `target` which has only `pickupKeys`.\n * @ja `pickupKeys` で指定されたプロパティのみを持つ `target` の Shallow Copy を取得\n *\n * @param target\n *  - `en` copy source object\n *  - `ja` コピー元オブジェクト\n * @param pickupKeys\n *  - `en` copy target keys\n *  - `ja` コピー対象のキー一覧\n */\nexport function partialize<T extends object, K extends keyof T>(target: T, ...pickupKeys: K[]): Writable<Pick<T, K>> {\n    if (!target || !isObject(target)) {\n        throw new TypeError(`${className(target)} is not an object.`);\n    }\n    return pickupKeys.reduce((obj, key) => {\n        key in target && (obj[key] = target[key]);\n        return obj;\n    }, {} as Writable<Pick<T, K>>);\n}\n","import {\n    TypeKeys,\n    isArray,\n    exists,\n    className,\n} from './types';\n\n/**\n * @en Type verifier interface definition. <br>\n *     If invalid value received, the method throws `TypeError`.\n * @ja 型検証のインターフェイス定義 <br>\n *     違反した場合は `TypeError` を発生\n *\n *\n */\ninterface Verifier {\n    /**\n     * @en Verification for the input value is not [[Nil]].\n     * @ja [[Nil]] でないことを検証\n     *\n     * @param notNil.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param notNil.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    notNil: (x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input is [[TypeKeys]].\n     * @ja 指定した [[TypeKeys]] であるか検証\n     *\n     * @param typeOf.type\n     *  - `en` one of [[TypeKeys]]\n     *  - `ja` [[TypeKeys]] を指定\n     * @param typeOf.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param typeOf.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    typeOf: (type: TypeKeys, x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input value is `Array`.\n     * @ja `Array` であるか検証\n     *\n     * @param array.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param array.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    array: (x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input value is `Iterable`.\n     * @ja `Iterable` であるか検証\n     *\n     * @param iterable.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param iterable.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    iterable: (x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input instance is equal comparative target constructor.\n     * @ja 指定コンストラクタのインスタンスであるか検証\n     *\n     * @param instanceOf.ctor\n     *  - `en` comparative target constructor\n     *  - `ja` 比較対象のコンストラクタ\n     * @param instanceOf.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param instanceOf.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    instanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input instance has `strictly` comparative target constructor.\n     * @ja 指定コンストラクタの厳密一致したインスタンスであるか検証\n     *\n     * @param ownInstanceOf.ctor\n     *  - `en` comparative target constructor\n     *  - `ja` 比較対象のコンストラクタ\n     * @param ownInstanceOf.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param ownInstanceOf.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    ownInstanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input instance has not `strictly` equal comparative target constructor.\n     * @ja 指定コンストラクタを持つインスタンスでないことを検証\n     *\n     * @param notOwnInstanceOf.ctor\n     *  - `en` comparative target constructor\n     *  - `ja` 比較対象のコンストラクタ\n     * @param notOwnInstanceOf.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param notOwnInstanceOf.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    notOwnInstanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input value has specified property.\n     * @ja 指定プロパティを持っているか検証\n     *\n     * @param hasProperty.prop\n     *  - `en` specified property\n     *  - `ja` 対象のプロパティ\n     * @param hasProperty.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param hasProperty.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    hasProperty: (x: unknown, prop: PropertyKey, message?: string | null) => void | never;\n\n    /**\n     * @en Verification for the input value has own specified property.\n     * @ja 指定プロパティを入力値自身持っているか検証\n     *\n     * @param hasOwnProperty.prop\n     *  - `en` specified property\n     *  - `ja` 対象のプロパティ\n     * @param hasOwnProperty.x\n     *  - `en` evaluated value\n     *  - `ja` 評価する値\n     * @param hasOwnProperty.message\n     *  - `en` custom error message\n     *  - `ja` カスタムエラーメッセージ\n     */\n    hasOwnProperty: (x: unknown, prop: PropertyKey, message?: string | null) => void | never;\n}\n\n/**\n * @en List of method for type verify.\n * @ja 型検証が提供するメソッド一覧\n */\ntype VerifyMethod = keyof Verifier;\n\n/**\n * @en Concrete type verifier object.\n * @ja 型検証実装オブジェクト\n *\n * @internal\n */\nconst _verifier: Verifier = {\n    notNil: (x: unknown, message?: string | null): void | never => {\n        if (null == x) {\n            exists(message) || (message = `${className(x)} is not a valid value.`);\n            throw new TypeError(message);\n        }\n    },\n\n    typeOf: (type: TypeKeys, x: unknown, message?: string | null): void | never => {\n        if (typeof x !== type) {\n            exists(message) || (message = `Type of ${className(x)} is not ${type}.`);\n            throw new TypeError(message);\n        }\n    },\n\n    array: (x: unknown, message?: string | null): void | never => {\n        if (!isArray(x)) {\n            exists(message) || (message = `${className(x)} is not an Array.`);\n            throw new TypeError(message);\n        }\n    },\n\n    iterable: (x: unknown, message?: string | null): void | never => {\n        if (!(Symbol.iterator in Object(x))) {\n            exists(message) || (message = `${className(x)} is not an iterable object.`);\n            throw new TypeError(message);\n        }\n    },\n\n    instanceOf: (ctor: Function, x: unknown, message?: string | null): void | never => {\n        if (!(x instanceof ctor)) {\n            exists(message) || (message = `${className(x)} is not an instance of ${ctor.name}.`);\n            throw new TypeError(message);\n        }\n    },\n\n    ownInstanceOf: (ctor: Function, x: unknown, message?: string | null): void | never => {\n        if (null == x || Object.getPrototypeOf(x) !== Object(ctor.prototype)) {\n            exists(message) || (message = `The object is not own instance of ${ctor.name}.`);\n            throw new TypeError(message);\n        }\n    },\n\n    notOwnInstanceOf: (ctor: Function, x: unknown, message?: string | null): void | never => {\n        if (null != x && Object.getPrototypeOf(x) === Object(ctor.prototype)) {\n            exists(message) || (message = `The object is own instance of ${ctor.name}.`);\n            throw new TypeError(message);\n        }\n    },\n\n    hasProperty: (x: any, prop: PropertyKey, message?: string | null): void | never => {    // eslint-disable-line @typescript-eslint/no-explicit-any\n        if (null == x || !(prop in x)) {\n            exists(message) || (message = `The object does not have property ${String(prop)}.`);\n            throw new TypeError(message);\n        }\n    },\n\n    hasOwnProperty: (x: unknown, prop: PropertyKey, message?: string | null): void | never => {\n        if (null == x || !Object.prototype.hasOwnProperty.call(x, prop)) {\n            exists(message) || (message = `The object does not have own property ${String(prop)}.`);\n            throw new TypeError(message);\n        }\n    },\n};\n\n/**\n * @en Verify method.\n * @ja 検証メソッド\n *\n * @param method\n *  - `en` method name which using\n *  - `ja` 使用するメソッド名\n * @param args\n *  - `en` arguments which corresponds to the method name\n *  - `ja` メソッド名に対応する引数\n */\nexport function verify<TMethod extends VerifyMethod>(method: TMethod, ...args: Parameters<Verifier[TMethod]>): void | never {\n    (_verifier[method] as any)(...args);    // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport { verify as default };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    TypedArray,\n    isFunction,\n    isArray,\n    isObject,\n    isIterable,\n    isTypedArray,\n    sameClass,\n} from './types';\n\n/** @internal helper for deepEqual() */\nfunction arrayEqual(lhs: unknown[], rhs: unknown[]): boolean {\n    const len = lhs.length;\n    if (len !== rhs.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (!deepEqual(lhs[i], rhs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** @internal helper for deepEqual() */\nfunction bufferEqual(lhs: SharedArrayBuffer | ArrayBuffer, rhs: SharedArrayBuffer | ArrayBuffer): boolean {\n    const size = lhs.byteLength;\n    if (size !== rhs.byteLength) {\n        return false;\n    }\n    let pos = 0;\n    if (size - pos >= 8) {\n        const len = size >>> 3;\n        const f64L = new Float64Array(lhs, 0, len);\n        const f64R = new Float64Array(rhs, 0, len);\n        for (let i = 0; i < len; i++) {\n            if (!Object.is(f64L[i], f64R[i])) {\n                return false;\n            }\n        }\n        pos = len << 3;\n    }\n    if (pos === size) {\n        return true;\n    }\n    const L = new DataView(lhs);\n    const R = new DataView(rhs);\n    if (size - pos >= 4) {\n        if (!Object.is(L.getUint32(pos), R.getUint32(pos))) {\n            return false;\n        }\n        pos += 4;\n    }\n    if (size - pos >= 2) {\n        if (!Object.is(L.getUint16(pos), R.getUint16(pos))) {\n            return false;\n        }\n        pos += 2;\n    }\n    if (size > pos) {\n        if (!Object.is(L.getUint8(pos), R.getUint8(pos))) {\n            return false;\n        }\n        pos += 1;\n    }\n    return pos === size;\n}\n\n/**\n * @en Performs a deep comparison between two values to determine if they are equivalent.\n * @ja 2値の詳細比較をし, 等しいかどうか判定\n */\nexport function deepEqual(lhs: unknown, rhs: unknown): boolean {\n    if (lhs === rhs) {\n        return true;\n    }\n    if (isFunction(lhs) && isFunction(rhs)) {\n        return lhs.length === rhs.length && lhs.name === rhs.name;\n    }\n    if (!isObject(lhs) || !isObject(rhs)) {\n        return false;\n    }\n    { // Primitive Wrapper Objects / Date\n        const valueL = lhs.valueOf();\n        const valueR = rhs.valueOf();\n        if (lhs !== valueL || rhs !== valueR) {\n            return valueL === valueR;\n        }\n    }\n    { // RegExp\n        const isRegExpL = lhs instanceof RegExp;\n        const isRegExpR = rhs instanceof RegExp;\n        if (isRegExpL || isRegExpR) {\n            return isRegExpL === isRegExpR && String(lhs) === String(rhs);\n        }\n    }\n    { // Array\n        const isArrayL = isArray(lhs);\n        const isArrayR = isArray(rhs);\n        if (isArrayL || isArrayR) {\n            return isArrayL === isArrayR && arrayEqual(lhs as any, rhs as any);\n        }\n    }\n    { // ArrayBuffer\n        const isBufferL = lhs instanceof ArrayBuffer;\n        const isBufferR = rhs instanceof ArrayBuffer;\n        if (isBufferL || isBufferR) {\n            return isBufferL === isBufferR && bufferEqual(lhs as any, rhs as any);\n        }\n    }\n    { // ArrayBufferView\n        const isBufferViewL = ArrayBuffer.isView(lhs);\n        const isBufferViewR = ArrayBuffer.isView(rhs);\n        if (isBufferViewL || isBufferViewR) {\n            return isBufferViewL === isBufferViewR && sameClass(lhs, rhs)\n                && bufferEqual((lhs as ArrayBufferView).buffer, (rhs as ArrayBufferView).buffer);\n        }\n    }\n    { // other Iterable\n        const isIterableL = isIterable(lhs);\n        const isIterableR = isIterable(rhs);\n        if (isIterableL || isIterableR) {\n            return isIterableL === isIterableR && arrayEqual([...(lhs as any)], [...(rhs as any)]);\n        }\n    }\n    if (sameClass(lhs, rhs)) {\n        const keysL = new Set(Object.keys(lhs));\n        const keysR = new Set(Object.keys(rhs));\n        if (keysL.size !== keysR.size) {\n            return false;\n        }\n        for (const key of keysL) {\n            if (!keysR.has(key)) {\n                return false;\n            }\n        }\n        for (const key of keysL) {\n            if (!deepEqual(lhs[key], rhs[key])) {\n                return false;\n            }\n        }\n    } else {\n        for (const key in lhs) {\n            if (!(key in rhs)) {\n                return false;\n            }\n        }\n        const keys = new Set<string>();\n        for (const key in rhs) {\n            if (!(key in lhs)) {\n                return false;\n            }\n            keys.add(key);\n        }\n        for (const key of keys) {\n            if (!deepEqual(lhs[key], rhs[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n//__________________________________________________________________________________________________//\n\n/** @internal clone RegExp */\nfunction cloneRegExp(regexp: RegExp): RegExp {\n    const result = new RegExp(regexp.source, regexp.flags);\n    result.lastIndex = regexp.lastIndex;\n    return result;\n}\n\n/** @internal clone ArrayBuffer */\nfunction cloneArrayBuffer(arrayBuffer: ArrayBuffer): ArrayBuffer {\n    const result = new ArrayBuffer(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n}\n\n/** @internal clone DataView */\nfunction cloneDataView(dataView: DataView): DataView {\n    const buffer = cloneArrayBuffer(dataView.buffer);\n    return new DataView(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/** @internal clone TypedArray */\nfunction cloneTypedArray<T extends TypedArray>(typedArray: T): T {\n    const buffer = cloneArrayBuffer(typedArray.buffer);\n    return new (typedArray as any).constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/** @internal merge Array */\nfunction mergeArray(target: any[], source: any[]): any[] {\n    for (let i = 0, len = source.length; i < len; i++) {\n        const oldValue = target[i];\n        const newValue = merge(oldValue, source[i]);\n        oldValue === newValue || (target[i] = newValue);\n    }\n    return target;\n}\n\n/** @internal merge Set */\nfunction mergeSet(target: Set<any>, source: Set<any>): Set<any> {\n    for (const item of source) {\n        target.has(item) || target.add(merge(undefined, item));\n    }\n    return target;\n}\n\n/** @internal merge Map */\nfunction mergeMap(target: Map<any, any>, source: Map<any, any>): Map<any, any> {\n    for (const [k, v] of source) {\n        const oldValue = target.get(k);\n        const newValue = merge(oldValue, v);\n        oldValue === newValue || target.set(k, newValue);\n    }\n    return target;\n}\n\n/** @internal helper for deepMerge() */\nfunction merge(target: unknown, source: unknown): any {\n    if (undefined === source || target === source) {\n        return target;\n    }\n    if (!isObject(source)) {\n        return source;\n    }\n    // Primitive Wrapper Objects / Date\n    if (source.valueOf() !== source) {\n        return deepEqual(target, source) ? target : new (source as any).constructor(source.valueOf());\n    }\n    // RegExp\n    if (source instanceof RegExp) {\n        return deepEqual(target, source) ? target : cloneRegExp(source);\n    }\n    // ArrayBuffer\n    if (source instanceof ArrayBuffer) {\n        return deepEqual(target, source) ? target : cloneArrayBuffer(source);\n    }\n    // ArrayBufferView\n    if (ArrayBuffer.isView(source)) {\n        return deepEqual(target, source) ? target : isTypedArray(source) ? cloneTypedArray(source) : cloneDataView(source as DataView);\n    }\n    // Array\n    if (Array.isArray(source)) {\n        return mergeArray(isArray(target) ? target : [], source);\n    }\n    // Set\n    if (source instanceof Set) {\n        return mergeSet(target instanceof Set ? target : new Set(), source);\n    }\n    // Map\n    if (source instanceof Map) {\n        return mergeMap(target instanceof Map ? target : new Map(), source);\n    }\n\n    const obj = isObject(target) ? target : {};\n    if (sameClass(target, source)) {\n        for (const key of Object.keys(source)) {\n            const oldValue = obj[key];\n            const newValue = merge(oldValue, source[key]);\n            oldValue === newValue || (obj[key] = newValue);\n        }\n    } else {\n        for (const key in source) {\n            const oldValue = obj[key];\n            const newValue = merge(oldValue, source[key]);\n            oldValue === newValue || (obj[key] = newValue);\n        }\n    }\n    return obj;\n}\n\n/**\n * @en Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n * @ja オブジェクトの再帰的マージを実行\n */\nexport function deepMerge<T, S1, S2, S3, S4, S5, S6, S7, S8, S9>(\n    target: T,\n    ...sources: [S1, S2?, S3?, S4?, S5?, S6?, S7?, S8?, S9?, ...any[]]\n): T & S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9;\nexport function deepMerge<X>(target: any, ...sources: any[]): X;\nexport function deepMerge(target: any, ...sources: any[]): any {\n    let result = target;\n    for (const source of sources) {\n        result = merge(result, source);\n    }\n    return result;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Create deep copy instance of source object.\n * @ja ディープコピーオブジェクトの生成\n */\nexport function deepCopy<T>(src: T): T {\n    return deepMerge(undefined, src);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    Nil,\n    Type,\n    Class,\n    Constructor,\n} from './types';\n\n/**\n * @en Mixin class's base interface.\n * @ja Mixin クラスの基底インターフェイス定義\n */\nexport declare class MixinClass {\n    /**\n     * @en call mixin source class's `super()`. <br>\n     *     This method should be called from constructor.\n     * @ja Mixin クラスの基底インターフェイス定義 <br>\n     *     コンストラクタから呼ぶことを想定\n     *\n     * @param srcClass\n     *  - `en` construction target class name. ex) from S1 available\n     *  - `ja` コンストラクトするクラス名を指定 ex) S1 から指定可能\n     * @param args\n     *  - `en` construction parameters\n     *  - `ja` コンストラクトに使用する引数\n     */\n    protected super<T extends Class>(srcClass: T, ...args: ConstructorParameters<T>): this;\n\n    /**\n     * @en Check the input class is mixined (excluding own class).\n     * @ja 指定クラスが Mixin されているか確認 (自身のクラスは含まれない)\n     *\n     * @param mixedClass\n     *  - `en` set target class constructor\n     *  - `ja` 対象クラスのコンストラクタを指定\n     */\n    public isMixedWith<T>(mixedClass: Constructor<T>): boolean;\n}\n\n/**\n * @en Mixed sub class constructor definitions.\n * @ja 合成したサブクラスのコンストラクタ定義\n */\nexport interface MixinConstructor<B extends Class, U> extends Type<U> {\n    /**\n     * @en constructor\n     * @ja コンストラクタ\n     *\n     * @param args\n     *  - `en` base class arguments\n     *  - `ja` 基底クラスに指定した引数\n     * @returns\n     *  - `en` union type of classes when calling [[mixins]]()\n     *  - `ja` [[mixins]]() に渡したクラスの集合\n     */\n    new(...args: ConstructorParameters<B>): U;\n}\n\n/**\n * @en Definition of [[setMixClassAttribute]] function's arguments.\n * @ja [[setMixClassAttribute]] の取りうる引数定義\n */\nexport interface MixClassAttribute {\n    /**\n     * @en Suppress providing constructor-trap for the mixin source class. In this case, `isMixedWith`, `instanceof` also becomes invalid. (for improving performance)\n     * @ja Mixin Source クラスに対して, コンストラクタトラップを抑止. これを指定した場合, `isMixedWith`, `instanceof` も無効になる. (パフォーマンス改善)\n     */\n    protoExtendsOnly: void;\n\n    /**\n     * @en Setup [Symbol.hasInstance] property. <br>\n     *     The class designated as a source of [[mixins]]() has [Symbol.hasInstance] property implicitly. <br>\n     *     It's used to avoid becoming the behavior `instanceof` doesn't intend when the class is extended from the mixined class the other place.\n     * @ja [Symbol.hasInstance] プロパティ設定<br>\n     *     [[mixins]]() のソースに指定されたクラスは [Symbol.hasInstance] を暗黙的に備えるため<br>\n     *     そのクラスが他で継承されている場合 `instanceof` が意図しない振る舞いとなるのを避けるために使用する.\n     */\n    instanceOf: ((inst: object) => boolean) | Nil;\n}\n\n//__________________________________________________________________________________________________//\n\nconst _objPrototype     = Object.prototype;\nconst _instanceOf       = Function.prototype[Symbol.hasInstance];\nconst _override         = Symbol('override');\nconst _isInherited      = Symbol('isInherited');\nconst _constructors     = Symbol('constructors');\nconst _classBase        = Symbol('classBase');\nconst _classSources     = Symbol('classSources');\nconst _protoExtendsOnly = Symbol('protoExtendsOnly');\n\n// object properties copy method\nfunction copyProperties(target: object, source?: object): void {\n    source && Object.getOwnPropertyNames(source)\n        .filter(key => !/(prototype|name|constructor)/.test(key))\n        .forEach(key => {\n            if (null == target[key]) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key) as PropertyDecorator);\n            }\n        });\n}\n\n// helper for setMixClassAttribute(target, 'instanceOf')\nfunction setInstanceOf<T extends {}>(target: Constructor<T>, method: ((inst: object) => boolean) | Nil): void {\n    const behaviour = method || (null === method ? undefined : ((i: object) => Object.prototype.isPrototypeOf.call(target.prototype, i)));\n    const applied = behaviour && Object.getOwnPropertyDescriptor(target, _override);\n    if (!applied) {\n        Object.defineProperties(target, {\n            [Symbol.hasInstance]: {\n                value: behaviour,\n                writable: true,\n                enumerable: false,\n            },\n            [_override]: {\n                value: behaviour ? true : undefined,\n                writable: true,\n            },\n        });\n    }\n}\n\n/**\n * @en Set the Mixin class attribute.\n * @ja Mixin クラスに対して属性を設定\n *\n * @example <br>\n *\n * ```ts\n * // 'protoExtendOnly'\n * class Base { constructor(a, b) {} };\n * class MixA { };\n * setMixClassAttribute(MixA, 'protoExtendsOnly');  // for improving construction performance\n * class MixB { constructor(c, d) {} };\n *\n * class MixinClass extends mixins(Base, MixA, MixB) {\n *     constructor(a, b, c, d){\n *         // calling `Base` constructor\n *         super(a, b);\n *\n *         // calling Mixin class's constructor\n *         this.super(MixA);        // no affect\n *         this.super(MixB, c, d);\n *     }\n * }\n *\n * const mixed = new MixinClass();\n * console.log(mixed instanceof MixA);    // false\n * console.log(mixed.isMixedWith(MixA));  // false\n *\n * // 'instanceOf'\n * class Base {};\n * class Source {};\n * class MixinClass extends mixins(Base, Source) {};\n *\n * class Other extends Source {};\n *\n * const mixed = new MixinClass();\n * console.log(mixed instanceof MixinClass);    // true\n * console.log(mixed instanceof Base);          // true\n * console.log(mixed instanceof Source);        // true\n * console.log(mixed instanceof Other);         // true ???\n *\n * setMixClassAttribute(Other, 'instanceOf'); // or setMixClassAttribute(Other, 'instanceOf', null);\n * console.log(mixed instanceof Other);         // false !\n * ```\n *\n * @param target\n *  - `en` set target constructor\n *  - `ja` 設定対象のコンストラクタ\n * @param attr\n *  - `en`:\n *    - `protoExtendsOnly`: Suppress providing constructor-trap for the mixin source class. (for improving performance)\n *    - `instanceOf`      : function by using [Symbol.hasInstance] <br>\n *                          Default behaviour is `{ return target.prototype.isPrototypeOf(instance) }`\n *                          If set `null`, delete [Symbol.hasInstance] property.\n *  - `ja`:\n *    - `protoExtendsOnly`: Mixin Source クラスに対して, コンストラクタトラップを抑止 (パフォーマンス改善)\n *    - `instanceOf`      : [Symbol.hasInstance] が使用する関数を指定 <br>\n *                          既定では `{ return target.prototype.isPrototypeOf(instance) }` が使用される\n *                         `null` 指定をすると [Symbol.hasInstance] プロパティを削除する\n */\nexport function setMixClassAttribute<T extends {}, U extends keyof MixClassAttribute>(\n    target: Constructor<T>,\n    attr: U,\n    method?: MixClassAttribute[U]\n): void {\n    switch (attr) {\n        case 'protoExtendsOnly':\n            target[_protoExtendsOnly] = true;\n            break;\n        case 'instanceOf':\n            setInstanceOf(target, method);\n            break;\n        default:\n            break;\n    }\n}\n\n/**\n * @en Mixin function for multiple inheritance. <br>\n *     Resolving type support for maximum 10 classes.\n * @ja 多重継承のための Mixin <br>\n *     最大 10 クラスの型解決をサポート\n *\n * @example <br>\n *\n * ```ts\n * class Base { constructor(a, b) {} };\n * class MixA { constructor(a, b) {} };\n * class MixB { constructor(c, d) {} };\n *\n * class MixinClass extends mixins(Base, MixA, MixB) {\n *     constructor(a, b, c, d){\n *         // calling `Base` constructor\n *         super(a, b);\n *\n *         // calling Mixin class's constructor\n *         this.super(MixA, a, b);\n *         this.super(MixB, c, d);\n *     }\n * }\n * ```\n *\n * @param base\n *  - `en` primary base class. super(args) is this class's one.\n *  - `ja` 基底クラスコンストラクタ. 同名プロパティ, メソッドは最優先される. super(args) はこのクラスのものが指定可能.\n * @param sources\n *  - `en` multiple extends class\n *  - `ja` 拡張クラスコンストラクタ\n * @returns\n *  - `en` mixined class constructor\n *  - `ja` 合成されたクラスコンストラクタ\n */\nexport function mixins<B extends Class, S1, S2, S3, S4, S5, S6, S7, S8, S9>(\n    base: B,\n    ...sources: [\n        Constructor<S1>,\n        Constructor<S2>?,\n        Constructor<S3>?,\n        Constructor<S4>?,\n        Constructor<S5>?,\n        Constructor<S6>?,\n        Constructor<S7>?,\n        Constructor<S8>?,\n        Constructor<S9>?,\n        ...any[]\n    ]): MixinConstructor<B, MixinClass & InstanceType<B> & S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9> {\n\n    let _hasSourceConstructor = false;\n\n    // eslint-disable-next-line @typescript-eslint/class-name-casing\n    class _MixinBase extends (base as any as Constructor<MixinClass>) {\n\n        private readonly [_constructors]: Map<Constructor<any>, Function | null>;\n        private readonly [_classBase]: Constructor<any>;\n\n        constructor(...args: any[]) {\n            // eslint-disable-next-line constructor-super\n            super(...args);\n\n            const constructors = new Map<Constructor<any>, Function>();\n            this[_constructors] = constructors;\n            this[_classBase] = base;\n\n            if (_hasSourceConstructor) {\n                for (const srcClass of sources) {\n                    if (!srcClass[_protoExtendsOnly]) {\n                        const handler = {\n                            apply: (target: any, thisobj: any, arglist: any[]) => {\n                                const obj = new srcClass(...arglist);\n                                copyProperties(this, obj);\n                            }\n                        };\n                        // proxy for 'construct' and cache constructor\n                        constructors.set(srcClass, new Proxy(srcClass, handler));\n                    }\n                }\n            }\n        }\n\n        protected super<T extends Class>(srcClass: T, ...args: ConstructorParameters<T>): this {\n            const map = this[_constructors];\n            const ctor = map.get(srcClass);\n            if (ctor) {\n                ctor(...args);\n                map.set(srcClass, null);    // prevent calling twice\n            }\n            return this;\n        }\n\n        public isMixedWith<T>(srcClass: Constructor<T>): boolean {\n            if (this.constructor === srcClass) {\n                return false;\n            } else if (this[_classBase] === srcClass) {\n                return true;\n            } else {\n                return this[_classSources].reduce((p, c) => p || (srcClass === c), false);\n            }\n        }\n\n        public static [Symbol.hasInstance](instance: any): boolean {\n            return Object.prototype.isPrototypeOf.call(_MixinBase.prototype, instance);\n        }\n\n        public [_isInherited]<T>(srcClass: Constructor<T>): boolean {\n            const ctors = this[_constructors];\n            if (ctors.has(srcClass)) {\n                return true;\n            }\n            for (const ctor of ctors.keys()) {\n                if (Object.prototype.isPrototypeOf.call(srcClass, ctor)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private get [_classSources](): Constructor<any>[] {\n            return [...this[_constructors].keys()];\n        }\n    }\n\n    for (const srcClass of sources) {\n        // provide custom instanceof\n        const desc = Object.getOwnPropertyDescriptor(srcClass, Symbol.hasInstance);\n        if (!desc || desc.writable) {\n            const orgInstanceOf = desc ? srcClass[Symbol.hasInstance] : _instanceOf;\n            setInstanceOf(srcClass, (inst: object) => {\n                return orgInstanceOf.call(srcClass, inst) || ((null != inst && inst[_isInherited]) ? inst[_isInherited](srcClass) : false);\n            });\n        }\n        // provide prototype\n        copyProperties(_MixinBase.prototype, srcClass.prototype);\n        let parent = Object.getPrototypeOf(srcClass.prototype);\n        while (_objPrototype !== parent) {\n            copyProperties(_MixinBase.prototype, parent);\n            parent = Object.getPrototypeOf(parent);\n        }\n        // check constructor\n        if (!_hasSourceConstructor) {\n            _hasSourceConstructor = !srcClass[_protoExtendsOnly];\n        }\n    }\n\n    return _MixinBase as any;\n}\n","/* eslint-disable no-invalid-this, @typescript-eslint/no-explicit-any */\n\nconst random = Math.random.bind(Math);\n\n/**\n * @en Execute shuffle of an array elements.\n * @ja 配列要素のシャッフル\n *\n * @param array\n *  - `en` source array\n *  - `ja` 入力配列\n * @param destructive\n *  - `en` true: destructive / false: non-destructive (default)\n *  - `ja` true: 破壊的 / false: 非破壊的 (既定)\n */\nexport function shuffle<T>(array: T[], destructive = false): T[] {\n    const source = destructive ? array : array.slice();\n    const len = source.length;\n    for (let i = len > 0 ? len >>> 0 : 0; i > 1;) {\n        const j = i * random() >>> 0;\n        const swap = source[--i];\n        source[i] = source[j];\n        source[j] = swap;\n    }\n    return source;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Execute stable sort by merge-sort algorithm.\n * @ja `merge-sort` による安定ソート\n *\n * @param array\n *  - `en` source array\n *  - `ja` 入力配列\n * @param comparator\n *  - `en` sort comparator function\n *  - `ja` ソート関数を指定\n * @param destructive\n *  - `en` true: destructive / false: non-destructive (default)\n *  - `ja` true: 破壊的 / false: 非破壊的 (既定)\n */\nexport function sort<T>(array: T[], comparator: (lhs: T, rhs: T) => number, destructive = false): T[] {\n    const source = destructive ? array : array.slice();\n    if (source.length < 2) {\n        return source;\n    }\n    const lhs = sort(source.splice(0, source.length >>> 1), comparator, true);\n    const rhs = sort(source.splice(0), comparator, true);\n    while (lhs.length && rhs.length) {\n        source.push(comparator(lhs[0], rhs[0]) <= 0 ? lhs.shift() as T : rhs.shift() as T);\n    }\n    return source.concat(lhs, rhs);\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Make index array.\n * @ja インデックス配列の作成\n *\n * @param array\n *  - `en` source array\n *  - `ja` 入力配列\n * @param excludes\n *  - `en` exclude index in return value.\n *  - `ja` 戻り値配列に含めないインデックスを指定\n */\nexport function indices<T>(array: T[], ...excludes: number[]): number[] {\n    const retval = [...array.keys()];\n\n    const len = array.length;\n    const exList = [...new Set(excludes)].sort((lhs, rhs) => lhs < rhs ? 1 : -1);\n    for (const ex of exList) {\n        if (0 <= ex && ex < len) {\n            retval.splice(ex, 1);\n        }\n    }\n\n    return retval;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en [[groupBy]]() options definition.\n * @ja [[groupBy]]() に指定するオプション定義\n */\nexport interface GroupByOptions<\n    T extends object,\n    TKEYS extends keyof T,\n    TSUMKEYS extends keyof T,\n    TGROUPKEY extends string\n> {\n    /**\n     * @en `GROUP BY` keys.\n     * @ja `GROUP BY` に指定するキー\n     */\n    keys: Extract<TKEYS, string>[];\n\n    /**\n     * @en Aggregatable keys.\n     * @ja 集計可能なキー一覧\n     */\n    sumKeys?: Extract<TSUMKEYS, string>[];\n\n    /**\n     * @en Grouped item access key. default: 'items',\n     * @ja グルーピングされた要素へのアクセスキー. 既定: 'items'\n     */\n    groupKey?: TGROUPKEY;\n}\n\n/**\n * @en Return type of [[groupBy]]().\n * @ja [[groupBy]]() が返却する型\n */\nexport type GroupByReturnValue<\n    T extends object,\n    TKEYS extends keyof T,\n    TSUMKEYS extends keyof T = never,\n    TGROUPKEY extends string = 'items'\n> = Readonly<Record<TKEYS, {}> & Record<TSUMKEYS, {}> & Record<TGROUPKEY, T[]>>;\n\n/**\n * @en Execute `GROUP BY` for array elements.\n * @ja 配列の要素の `GROUP BY` 集合を抽出\n *\n * @param array\n *  - `en` source array\n *  - `ja` 入力配列\n * @param options\n *  - `en` `GROUP BY` options\n *  - `ja` `GROUP BY` オプション\n */\nexport function groupBy<\n    T extends object,\n    TKEYS extends keyof T,\n    TSUMKEYS extends keyof T = never,\n    TGROUPKEY extends string = 'items'\n>(array: T[], options: GroupByOptions<T, TKEYS, TSUMKEYS, TGROUPKEY>): GroupByReturnValue<T, TKEYS, TSUMKEYS, TGROUPKEY>[] {\n    const { keys, sumKeys, groupKey } = options;\n    const _groupKey = groupKey || 'items';\n    const _sumKeys: string[] = sumKeys || [];\n    _sumKeys.push(_groupKey);\n\n    const hash = array.reduce((res: T, data: T) => {\n        // create groupBy internal key\n        const _key = keys.reduce((s, k) => s + String(data[k]), '');\n\n        // init keys\n        if (!(_key in res)) {\n            const keyList = keys.reduce((h, k: string) => {\n                h[k] = data[k];\n                return h;\n            }, {});\n\n            res[_key] = _sumKeys.reduce((h, k: string) => {\n                h[k] = 0;\n                return h;\n            }, keyList);\n        }\n\n        const resKey = res[_key];\n\n        // sum properties\n        for (const k of _sumKeys) {\n            if (_groupKey === k) {\n                resKey[k] = resKey[k] || [];\n                resKey[k].push(data);\n            } else {\n                resKey[k] += data[k];\n            }\n        }\n\n        return res;\n    }, {});\n\n    return Object.values(hash);\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Substitution method of `Array.prototype.map()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.map()` の代替メソッド\n * \n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant *Array* as value.\n *  - `ja` イテレーション結果配列を格納した Promise オブジェクト\n */\nexport async function map<T, U>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => U | Promise<U>, thisArg?: any): Promise<U[]> {\n    return Promise.all(\n        array.map(async (v, i, a) => {\n            return await callback.call(thisArg || this, v, i, a);\n        })\n    );\n}\n\n/**\n * @en Substitution method of `Array.prototype.filter()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.filter()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant *Array* as value.\n *  - `ja` イテレーション結果配列を格納した Promise オブジェクト\n */\nexport async function filter<T>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: any): Promise<T[]> {\n    const bits: boolean[] = await map(array, (v, i, a) => callback.call(thisArg || this, v, i, a));\n    return array.filter(() => bits.shift());\n}\n\n/**\n * @en Substitution method of `Array.prototype.find()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.find()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant value.\n *  - `ja` イテレーション結果を格納した Promise オブジェクト\n */\nexport async function find<T>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: any): Promise<T | undefined> {\n    for (const [i, v] of array.entries()) {\n        if (await callback.call(thisArg || this, v, i, array)) {\n            return v;\n        }\n    }\n    return undefined;\n}\n\n/**\n * @en Substitution method of `Array.prototype.findIndex()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.findIndex()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant index value.\n *  - `ja` インデックスを格納した Promise オブジェクト\n */\nexport async function findIndex<T>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: any): Promise<number> {\n    for (const [i, v] of array.entries()) {\n        if (await callback.call(thisArg || this, v, i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * @en Substitution method of `Array.prototype.some()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.some()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant boolean value.\n *  - `ja` 真偽値を格納した Promise オブジェクト\n */\nexport async function some<T>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => unknown | Promise<unknown>, thisArg?: any): Promise<boolean> {\n    for (const [i, v] of array.entries()) {\n        if (await callback.call(thisArg || this, v, i, array)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @en Substitution method of `Array.prototype.every()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.every()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param thisArg\n *  - `en` Value to use as *this* when executing the `callback`.\n *  - `ja` `callback` 実行コンテキスト\n * @returns\n *  - `en` Returns a Promise with the resultant boolean value.\n *  - `ja` 真偽値を格納した Promise オブジェクト\n */\nexport async function every<T>(this: any, array: T[], callback: (value: T, index: number, array: T[]) => unknown | Promise<unknown>, thisArg?: any): Promise<boolean> {\n    for (const [i, v] of array.entries()) {\n        if (!await callback.call(thisArg || this, v, i, array)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @en Substitution method of `Array.prototype.reduce()` which also accepts asynchronous callback.\n * @ja 非同期コールバックを指定可能な `Array.prototype.reduce()` の代替メソッド\n *\n * @param array\n *  - `en` Array to iterate over.\n *  - `ja` 入力配列\n * @param callback\n *  - `en` Function to apply each item in `array`.\n *  - `ja` イテレーション適用関数\n * @param initialValue\n *  - `en` Used as first argument to the first call of `callback`.\n *  - `ja` `callback` に渡される初期値\n * @returns\n *  - `en` Returns a Promise with the resultant *Array* as value.\n *  - `ja` イテレーション結果配列を格納した Promise オブジェクト\n */\nexport async function reduce<T, U>(\n    array: T[],\n    callback: (accumulator: U, currentValue: T, currentIndex: number, array: T[]) => U | Promise<U>,\n    initialValue?: U\n): Promise<U> {\n    if (array.length <= 0 && undefined === initialValue) {\n        throw TypeError('Reduce of empty array with no initial value');\n    }\n\n    const hasInit = (undefined !== initialValue);\n    let acc = (hasInit ? initialValue : array[0]) as U;\n\n    for (const [i, v] of array.entries()) {\n        if (!(!hasInit && 0 === i)) {\n            acc = await callback(acc, v, i, array);\n        }\n    }\n\n    return acc;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nfunction callable(): any {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return accessible;\n}\n\nconst accessible: any = new Proxy(callable, {\n    get: (target, name) => {\n        const prop = target[name];\n        if (null != prop) {\n            return prop;\n        } else {\n            return accessible;\n        }\n    },\n});\n\nfunction create(): any {\n    const stub = new Proxy({}, {\n        get: (target, name) => {\n            const prop = target[name];\n            if (null != prop) {\n                return prop;\n            } else {\n                return accessible;\n            }\n        },\n    });\n\n    Object.defineProperty(stub, 'stub', {\n        value: true,\n        writable: false,\n    });\n\n    return stub;\n}\n\n/**\n * @en Get safe accessible object.\n * @ja 安全にアクセス可能なオブジェクトの取得\n *\n * @example <br>\n *\n * ```ts\n * const safeWindow = safe(globalThis.window);\n * console.log(null != safeWindow.document);    // true\n * const div = safeWindow.document.createElement('div');\n * console.log(null != div);    // true\n * ```\n *\n * @param target\n *  - `en` A reference of an object with a possibility which exists.\n *  - `ja` 存在しうるオブジェクトの参照\n * @returns\n *  - `en` Reality or stub instance.\n *  - `ja` 実体またはスタブインスタンス\n */\nexport function safe<T>(target: T): T {\n    return target || create();\n}\n","/* eslint-disable @typescript-eslint/no-empty-interface, @typescript-eslint/no-explicit-any */\n\nimport { getGlobal } from './config';\nimport { safe } from './safe';\n\n/**\n * @en Type of handle for timer functions.\n * @ja タイマー関数に使用するハンドル型\n */\nexport interface TimerHandle { }\n\n/**\n * @en Type of timer start functions.\n * @ja タイマー開始関数の型\n */\nexport type TimerStartFunction = (handler: Function, timeout?: number, ...args: any[]) => TimerHandle;\n\n/**\n * @en Type of timer stop functions.\n * @ja タイマー停止関数の型\n */\nexport type TimerStopFunction = (handle: TimerHandle) => void;\n\nconst root: any = getGlobal();\nconst _setTimeout: TimerStartFunction = safe(root.setTimeout);\nconst _clearTimeout: TimerStopFunction = safe(root.clearTimeout);\nconst _setInterval: TimerStartFunction = safe(root.setInterval);\nconst _clearInterval: TimerStopFunction = safe(root.clearInterval);\n\nexport {\n    _setTimeout as setTimeout,\n    _clearTimeout as clearTimeout,\n    _setInterval as setInterval,\n    _clearInterval as clearInterval,\n};\n","import {\n    Primitive,\n    TypedData,\n    isString,\n    isObject,\n} from './types';\nimport { setTimeout } from './timer';\n\n/**\n * @en Ensure asynchronous execution.\n * @ja 非同期実行を保証\n *\n * @example <br>\n *\n * ```ts\n * post(() => exec(arg));\n * ```\n *\n * @param executor\n *  - `en` implement as function scope.\n *  - `ja` 関数スコープとして実装\n*/\nexport function post<T>(executor: () => T): Promise<T> {\n    return Promise.resolve().then(executor);\n}\n\n/**\n * @en Generic No-Operation.\n * @ja 汎用 No-Operation\n */\nexport function noop(...args: any[]): any {    // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n    // noop\n}\n\n/**\n * @en Wait for the designation elapse.\n * @ja 指定時間処理を待機\n *\n * @param elapse\n *  - `en` wait elapse [msec].\n *  - `ja` 待機時間 [msec]\n */\nexport function sleep(elapse: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, elapse));\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Create escape function from map.\n * @ja 文字置換関数を作成\n *\n * @param map\n *  - `en` key: target char, value: replace char\n *  - `ja` key: 置換対象, value: 置換文字\n * @returns\n *  - `en` espace function\n *  - `ja` エスケープ関数\n */\nexport function createEscaper(map: object): (src: Primitive) => string {\n    const escaper = (match: string): string => {\n        return map[match];\n    };\n\n    const source = `(?:${Object.keys(map).join('|')})`;\n    const regexTest = RegExp(source);\n    const regexReplace = RegExp(source, 'g');\n\n    return (src: Primitive): string => {\n        src = (null == src || 'symbol' === typeof src) ? '' : String(src);\n        return regexTest.test(src) ? src.replace(regexReplace, escaper) : src;\n    };\n}\n\n/**\n * @en Escape HTML string\n * @ja HTML で使用する文字を制御文字に置換\n *\n * @brief <br>\n *\n * ```ts\n * const mapHtmlEscape = {\n *     '<': '&lt;',\n *     '>': '&gt;',\n *     '&': '&amp;',\n *     '\"': '&quot;',\n *     \"'\": '&#39;',\n *     '`': '&#x60;'\n * };\n * ```\n */\nexport const escapeHTML = createEscaper({\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#x60;'\n});\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert to the style compulsion value from input string.\n * @ja 入力文字列を型強制した値に変換\n *\n * @param data\n *  - `en` input string\n *  - `ja` 変換対象の文字列\n */\nexport function toTypedData(data: string | undefined): TypedData | undefined {\n    if ('true' === data) {\n        // boolean: true\n        return true;\n    } else if ('false' === data) {\n        // boolean: false\n        return false;\n    } else if ('null' === data) {\n        // null\n        return null;\n    } else if (data === String(Number(data))) {\n        // number: 数値変換 → 文字列変換で元に戻るとき\n        return Number(data);\n    } else if (data && /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/.test(data)) {\n        // object\n        return JSON.parse(data);\n    } else {\n        // string / undefined\n        return data;\n    }\n}\n\n/**\n * @en Convert to string from [[TypedData]].\n * @ja [[TypedData]] を文字列に変換\n *\n * @param data\n *  - `en` input string\n *  - `ja` 変換対象の文字列\n */\nexport function fromTypedData(data: TypedData | undefined): string | undefined {\n    if (undefined === data || isString(data)) {\n        return data;\n    } else if (isObject(data)) {\n        return JSON.stringify(data);\n    } else {\n        return String(data);\n    }\n}\n\n/**\n * @en Convert to `Web API` stocked type. <br>\n *     Ensure not to return `undefined` value.\n * @ja `Web API` 格納形式に変換 <br>\n *     `undefined` を返却しないことを保証\n */\nexport function dropUndefined<T>(value: T | null | undefined, nilSerialize = false): T | 'null' | 'undefined' | null {\n    return null != value ? value : (nilSerialize ? String(value) : null) as T | 'null' | 'undefined' | null;\n}\n\n/**\n * @en Deserialize from `Web API` stocked type. <br>\n *     Convert from 'null' or 'undefined' string to original type.\n * @ja 'null' or 'undefined' をもとの型に戻す\n */\nexport function restoreNil<T>(value: T | 'null' | 'undefined'): T | null | undefined {\n    if ('null' === value) {\n        return null;\n    } else if ('undefined' === value) {\n        return undefined;\n    } else {\n        return value;\n    }\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Converts first letter of the string to uppercase.\n * @ja 最初の文字を大文字に変換\n *\n *\n * @example <br>\n *\n * ```ts\n * capitalize(\"foo Bar\");\n * // => \"Foo Bar\"\n *\n * capitalize(\"FOO Bar\", true);\n * // => \"Foo bar\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n * @param lowercaseRest\n *  - `en` If `true` is passed, the rest of the string will be converted to lower case\n *  - `ja` `true` を指定した場合, 2文字目以降も小文字化\n */\nexport function capitalize(src: string, lowercaseRest = false): string {\n    const remainingChars = !lowercaseRest ? src.slice(1) : src.slice(1).toLowerCase();\n    return src.charAt(0).toUpperCase() + remainingChars;\n}\n\n/**\n * @en Converts first letter of the string to lowercase.\n * @ja 最初の文字を小文字化\n *\n * @example <br>\n *\n * ```ts\n * decapitalize(\"Foo Bar\");\n * // => \"foo Bar\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n */\nexport function decapitalize(src: string): string {\n    return src.charAt(0).toLowerCase() + src.slice(1);\n}\n\n/**\n * @en Converts underscored or dasherized string to a camelized one. <br>\n *     Begins with a lower case letter unless it starts with an underscore, dash or an upper case letter.\n * @ja `_`, `-` 区切り文字列をキャメルケース化 <br>\n *     `-` または大文字スタートであれば, 大文字スタートが既定値\n *\n * @example <br>\n *\n * ```ts\n * camelize(\"moz-transform\");\n * // => \"mozTransform\"\n *\n * camelize(\"-moz-transform\");\n * // => \"MozTransform\"\n *\n * camelize(\"_moz_transform\");\n * // => \"MozTransform\"\n *\n * camelize(\"Moz-transform\");\n * // => \"MozTransform\"\n *\n * camelize(\"-moz-transform\", true);\n * // => \"mozTransform\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n * @param lower\n *  - `en` If `true` is passed, force converts to lower camel case in starts with the special case.\n *  - `ja` 強制的に小文字スタートする場合には `true` を指定\n */\nexport function camelize(src: string, lower = false): string {\n    src = src.trim().replace(/[-_\\s]+(.)?/g, (match, c) => {\n        return c ? c.toUpperCase() : '';\n    });\n\n    if (true === lower) {\n        return decapitalize(src);\n    } else {\n        return src;\n    }\n}\n\n/**\n * @en Converts string to camelized class name. First letter is always upper case.\n * @ja 先頭大文字のキャメルケースに変換\n *\n * @example <br>\n *\n * ```ts\n * classify(\"some_class_name\");\n * // => \"SomeClassName\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n */\nexport function classify(src: string): string {\n    return capitalize(camelize(src.replace(/[\\W_]/g, ' ')).replace(/\\s/g, ''));\n}\n\n/**\n * @en Converts a camelized or dasherized string into an underscored one.\n * @ja キャメルケース or `-` つなぎ文字列を `_` つなぎに変換\n *\n * @example <br>\n *\n * ```ts\n * underscored(\"MozTransform\");\n * // => \"moz_transform\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n */\nexport function underscored(src: string): string {\n    return src.trim().replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n}\n\n/**\n * @en Converts a underscored or camelized string into an dasherized one.\n * @ja キャメルケース or `_` つなぎ文字列を `-` つなぎに変換\n *\n * @example <br>\n *\n * ```ts\n * dasherize(\"MozTransform\");\n * // => \"-moz-transform\"\n * ```\n *\n * @param src\n *  - `en` source string\n *  - `ja` 変換元文字列\n */\nexport function dasherize(src: string): string {\n    return src.trim().replace(/([A-Z])/g, '-$1').replace(/[_\\s]+/g, '-').toLowerCase();\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    Arguments,\n    isString,\n    isArray,\n    isSymbol,\n    className,\n    verify,\n} from '@cdp/core-utils';\nimport { Subscription, Subscribable } from './interfaces';\n\n/** @internal Lisner 格納形式 */\ntype ListenersMap<T> = Map<keyof T, Set<(...args: T[keyof T][]) => unknown>>;\n\n/** @internal Lisner の弱参照 */\nconst _mapListeners = new WeakMap<EventPublisher<any>, ListenersMap<any>>();\n\n/** @internal LisnerMap の取得 */\nfunction listeners<T>(instance: EventPublisher<T>): ListenersMap<T> {\n    if (!_mapListeners.has(instance)) {\n        throw new TypeError('This is not a valid EventPublisher.');\n    }\n    return _mapListeners.get(instance) as ListenersMap<T>;\n}\n\n/** @internal Channel の型検証 */\nfunction validChannel(channel: unknown): void | never {\n    if (isString(channel) || isSymbol(channel)) {\n        return;\n    }\n    throw new TypeError(`Type of ${className(channel)} is not a valid channel.`);\n}\n\n/** @internal Listener の型検証 */\nfunction validListener(listener?: (...args: unknown[]) => unknown): any | never {\n    if (null != listener) {\n        verify('typeOf', 'function', listener);\n    }\n    return listener;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Eventing framework class with ensuring type-safe for TypeScript. <br>\n *     The client of this class can implement original Pub-Sub (Observer) design pattern.\n * @ja 型安全を保障するイベント登録・発行クラス <br>\n *     クライアントは本クラスを派生して独自の Pub-Sub (Observer) パターンを実装可能\n *\n * @example <br>\n *\n * ```ts\n * import { EventPublisher } from '@cdp/event-publisher';\n *\n * // declare event interface\n * interface SampleEvent {\n *   hoge: [number, string];        // callback function's args type tuple\n *   foo: [void];                   // no args\n *   hoo: void;                     // no args (same the upon)\n *   bar: [Error];                  // any class is available.\n *   baz: Error | Number;           // if only one argument, `[]` is not required.\n * }\n *\n * // declare client class\n * class SamplePublisher extends EventPublisher<SampleEvent> {\n *   :\n *   someMethod(): void {\n *     this.publish('hoge', 100, 'test');       // OK. standard usage.\n *     this.publish('hoge', 100, true);         // NG. argument of type 'true' is not assignable\n *                                              //     to parameter of type 'string | undefined'.\n *     this.publish('hoge', 100);               // OK. all args to be optional automatically.\n *     this.publish('foo');                     // OK. standard usage.\n *     this.publish('foo', 100);                // NG. argument of type '100' is not assignable\n *                                              //     to parameter of type 'void | undefined'.\n *   }\n * }\n *\n * const sample = new SamplePublisher();\n *\n * sample.on('hoge', (a: number, b: string) => { ... });    // OK. standard usage.\n * sample.on('hoge', (a: number, b: boolean) => { ... });   // NG. types of parameters 'b'\n *                                                          //     and 'args_1' are incompatible.\n * sample.on('hoge', (a) => { ... });                       // OK. all args\n *                                                          //     to be optional automatically.\n * sample.on('hoge', (a, b, c) => { ... });                 // NG. expected 1-2 arguments,\n *                                                          //     but got 3.\n * ```\n */\nexport abstract class EventPublisher<Event> implements Subscribable<Event> {\n\n    /** constructor */\n    constructor() {\n        verify('instanceOf', EventPublisher, this);\n        _mapListeners.set(this, new Map());\n    }\n\n    /**\n     * @en Notify event to clients.\n     * @ja event 発行\n     *\n     * @param channel\n     *  - `en` event channel key. (string | symbol)\n     *  - `ja` イベントチャネルキー (string | symbol)\n     * @param args\n     *  - `en` arguments for callback function of the `channel` corresponding.\n     *  - `ja` `channel` に対応したコールバック関数に渡す引数\n     */\n    protected publish<Channel extends keyof Event>(channel: Channel, ...args: Arguments<Partial<Event[Channel]>>): void {\n        const map = listeners(this);\n        validChannel(channel);\n        const list = map.get(channel);\n        if (!list) {\n            return;\n        }\n        for (const listener of list) {\n            try {\n                const handled = listener(...args);\n                // if received 'true', stop delegation.\n                if (true === handled) {\n                    break;\n                }\n            } catch (e) {\n                Promise.reject(e);\n            }\n        }\n    }\n\n///////////////////////////////////////////////////////////////////////\n// implements: Subscribable<Event>\n\n    /**\n     * @en Check whether this object has clients.\n     * @ja クライアントが存在するか判定\n     *\n     * @param channel\n     *  - `en` event channel key. (string | symbol)\n     *  - `ja` イベントチャネルキー (string | symbol)\n     * @param listener\n     *  - `en` callback function of the `channel` corresponding.\n     *  - `ja` `channel` に対応したコールバック関数\n     */\n    has<Channel extends keyof Event>(channel?: Channel, listener?: (...args: Arguments<Event[Channel]>) => unknown): boolean {\n        const map = listeners(this);\n        if (null == channel) {\n            return map.size > 0;\n        }\n        validChannel(channel);\n        if (null == listener) {\n            return map.has(channel);\n        }\n        validListener(listener);\n        const list = map.get(channel);\n        return list ? list.has(listener) : false;\n    }\n\n    /**\n     * @en Returns registered channel keys.\n     * @ja 登録されているチャネルキーを返却\n     */\n    channels(): (keyof Event)[] {\n        return [...listeners(this).keys()];\n    }\n\n    /**\n     * @en Unsubscribe event(s).\n     * @ja イベント購読解除\n     *\n     * @param channel\n     *  - `en` target event channel key. (string | symbol)\n     *         When not set this parameter, everything is released.\n     *  - `ja` 対象のイベントチャネルキー (string | symbol)\n     *         指定しない場合はすべて解除\n     * @param listener\n     *  - `en` callback function of the `channel` corresponding.\n     *         When not set this parameter, all same `channel` listeners are released.\n     *  - `ja` `channel` に対応したコールバック関数\n     *         指定しない場合は同一 `channel` すべてを解除\n     */\n    off<Channel extends keyof Event>(channel?: Channel | Channel[], listener?: (...args: Arguments<Event[Channel]>) => unknown): void {\n        const map = listeners(this);\n        if (null == channel) {\n            map.clear();\n            return;\n        }\n\n        const channels = isArray(channel) ? channel : [channel];\n        const callback = validListener(listener);\n        for (const ch of channels) {\n            validChannel(ch);\n            if (null == callback) {\n                map.delete(ch);\n                continue;\n            } else {\n                const list = map.get(ch);\n                if (list) {\n                    list.delete(callback);\n                    list.size > 0 || map.delete(ch);\n                }\n            }\n        }\n    }\n\n    /**\n     * @en Subscrive event(s).\n     * @ja イベント購読設定\n     *\n     * @param channel\n     *  - `en` target event channel key. (string | symbol)\n     *  - `ja` 対象のイベントチャネルキー (string | symbol)\n     * @param listener\n     *  - `en` callback function of the `channel` corresponding.\n     *  - `ja` `channel` に対応したコールバック関数\n     */\n    on<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription {\n        const map = listeners(this);\n        validListener(listener);\n\n        const channels = isArray(channel) ? channel : [channel];\n        for (const ch of channels) {\n            validChannel(ch);\n            map.has(ch) ? map.get(ch)!.add(listener) : map.set(ch, new Set([listener])); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        }\n\n        return Object.freeze({\n            get enable() {\n                for (const ch of channels) {\n                    const list = map.get(ch);\n                    if (!list || !list.has(listener)) {\n                        this.unsubscribe();\n                        return false;\n                    }\n                }\n                return true;\n            },\n            unsubscribe() {\n                for (const ch of channels) {\n                    const list = map.get(ch);\n                    if (list) {\n                        list.delete(listener);\n                        list.size > 0 || map.delete(ch);\n                    }\n                }\n            },\n        });\n    }\n\n    /**\n     * @en Subscrive event(s) but it causes the bound callback to only fire once before being removed.\n     * @ja 一度だけハンドリング可能なイベント購読設定\n     *\n     * @param channel\n     *  - `en` target event channel key. (string | symbol)\n     *  - `ja` 対象のイベントチャネルキー (string | symbol)\n     * @param listener\n     *  - `en` callback function of the `channel` corresponding.\n     *  - `ja` `channel` に対応したコールバック関数\n     */\n    once<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription {\n        const context = this.on(channel, listener);\n        const managed = this.on(channel, () => {\n            context.unsubscribe();\n            managed.unsubscribe();\n        });\n        return context;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Arguments } from '@cdp/core-utils';\nimport { Subscribable } from './interfaces';\nimport { EventPublisher } from './publisher';\n\n// re-export\nexport { Arguments as EventArguments };\n\n/**\n * @en Eventing framework object able to call `publish()` method from outside.\n * @ja 外部からの `publish()` を可能にしたイベント登録・発行クラス\n *\n * @example <br>\n *\n * ```ts\n * import { EventBroker } from '@cdp/event-publisher';\n *\n * // declare event interface\n * interface SampleEvent {\n *   hoge: [number, string];        // callback function's args type tuple\n * }\n *\n * const broker = new EventBroker<SampleEvent>();\n * broker.publish('hoge', 100, 'test');     // OK. standard usage.\n * broker.publish('hoge', 100, true);       // NG. argument of type 'true' is not assignable\n *                                          //     to parameter of type 'string | undefined'.\n * ```\n */\nexport interface EventBroker<Event extends {}> extends Subscribable<Event> {\n    /**\n     * @en Notify event to clients.\n     * @ja event 発行\n     *\n     * @param channel\n     *  - `en` event channel key. (string | symbol)\n     *  - `ja` イベントチャネルキー (string | symbol)\n     * @param args\n     *  - `en` arguments for callback function of the `channel` corresponding.\n     *  - `ja` `channel` に対応したコールバック関数に渡す引数\n     */\n    publish<Channel extends keyof Event>(channel: Channel, ...args: Arguments<Partial<Event[Channel]>>): void;\n}\n\n/**\n * @en Constructor of EventBroker\n * @ja EventBroker のコンストラクタ実体\n */\nexport const EventBroker: {\n    readonly prototype: EventBroker<any>;\n    new <T>(): EventBroker<T>;\n} = EventPublisher as any;\n","import { EventBroker, Subscription } from '@cdp/event-publisher';\n\n/** @internal */\nexport const _cancel = Symbol('cancel');\n/** @internal */\nexport const _close = Symbol('close');\n\n/**\n * @en CancelToken state definitions.\n * @ja CancelToken の状態定義\n *\n * @internal\n */\nexport const enum CancelTokenState {\n    /** キャンセル受付可能 */\n    OPEN        = 0x0,\n    /** キャンセル受付済み */\n    REQUESTED   = 0x1,\n    /** キャンセル受付不可 */\n    CLOSED      = 0x2,\n}\n\n/**\n * @en Cancel event definitions.\n * @ja キャンセルイベント定義\n *\n * @internal\n */\nexport interface CancelEvent<T> {\n    cancel: [T];\n}\n\n/**\n * @en Internal CancelToken interface.\n * @ja CancelToken の内部インターフェイス定義\n *\n * @internal\n */\nexport interface CancelTokenContext<T extends {}> {\n    readonly publisher: EventBroker<CancelEvent<T>>;\n    readonly subscriptions: Set<Subscription>;\n    reason: T | undefined;\n    status: CancelTokenState;\n}\n\n/**\n * @en Invalid subscription object declaration.\n * @ja 無効な Subscription オブジェクト\n *\n * @internal\n */\nexport const invalidSubscription = Object.freeze({\n    enable: false,\n    unsubscribe() { /* noop */ }\n}) as Subscription;\n","/* eslint-disable no-redeclare, @typescript-eslint/no-explicit-any */\n\nimport { verify } from '@cdp/core-utils';\nimport { EventBroker, Subscription } from '@cdp/event-publisher';\nimport {\n    _cancel,\n    _close,\n    CancelTokenState,\n    CancelTokenContext,\n    invalidSubscription,\n} from './internal';\n\n/**\n * @en Cancellation source interface.\n * @ja キャンセル管理インターフェイス\n */\nexport interface CancelTokenSource<T extends {} = {}> {\n    /**\n     * @en [[CancelToken]] getter.\n     * @ja [[CancelToken]] 取得\n     */\n    readonly token: CancelToken<T>;\n\n    /**\n     * @en Execute cancel.\n     * @ja キャンセル実行\n     *\n     * @param reason\n     *  - `en` cancellation reason. this arg is transmitted in promise chain.\n     *  - `ja` キャンセルの理由を指定. `Promise` チェインに伝達される.\n     */\n    cancel(reason: T): void;\n\n    /**\n     * @en Break up cancellation reception.\n     * @ja キャンセル受付を終了\n     */\n    close(): void;\n}\n\n/** @internal */\nconst _tokens = new WeakMap<CancelToken<any>, CancelTokenContext<any>>();\n\n/** @internal */\nfunction getContext<T>(instance: CancelToken<T>): CancelTokenContext<T> {\n    if (!_tokens.has(instance)) {\n        throw new TypeError('The object is not a valid CancelToken.');\n    }\n    return _tokens.get(instance) as CancelTokenContext<T>;\n}\n\n/**\n * @en The token object to which unification processing for asynchronous processing cancellation is offered. <br>\n *     Origin is `CancellationToken` of `.NET Framework`.\n * @ja 非同期処理キャンセルのための統一処理を提供するトークンオブジェクト <br>\n *     オリジナルは `.NET Framework` の `CancellationToken`\n *\n * @see https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads\n *\n * @example <br>\n *\n * ```ts\n * import { CancelToken } from '@cdp/promise';\n * ```\n *\n * - Basic Usage\n *\n * ```ts\n * const token = new CancelToken((cancel, close) => {\n *   button1.onclick = ev => cancel(new Error('Cancel'));\n *   button2.onclick = ev => close();\n * });\n * ```\n *\n * or\n *\n * ```ts\n * const { cancel, close, token } = CancelToken.source();\n * button1.onclick = ev => cancel(new Error('Cancel'));\n * button2.onclick = ev => close();\n * ```\n *\n * - Use with Promise\n *\n * ```ts\n * const { cancel, close, token } = CancelToken.source();\n * const promise = new Promise((ok, ng) => { ... }, token);\n * promise\n *   .then(...)\n *   .then(...)\n *   .then(...)\n *   .catch(reason => {\n *     // check reason\n *   });\n * ```\n *\n * - Register & Unregister callback(s)\n *\n * ```ts\n * const { cancel, close, token } = CancelToken.source();\n * const subscription = token.register(reason => {\n *   console.log(reason.message);\n * });\n * if (someCase) {\n *   subscription.unsubscribe();\n * }\n * ```\n */\nexport class CancelToken<T extends {} = {}> {\n\n    /**\n     * @en Create [[CancelTokenSource]] instance.\n     * @ja [[CancelTokenSource]] インスタンスの取得\n     *\n     * @param linkedTokens\n     *  - `en` relating already made [[CancelToken]] instance.\n     *        You can attach to the token that to be a cancellation target.\n     *  - `ja` すでに作成された [[CancelToken]] 関連付ける場合に指定\n     *        渡された token はキャンセル対象として紐づけられる\n     */\n    public static source<T extends {} = {}>(...linkedTokens: CancelToken[]): CancelTokenSource<T> {\n        let cancel!: (reason: T) => void;\n        let close!: () => void;\n        const token = new CancelToken<T>((onCancel, onClose) => {\n            cancel = onCancel;\n            close = onClose;\n        }, ...linkedTokens);\n        return Object.freeze({ token, cancel, close });\n    }\n\n    /**\n     * constructor\n     *\n     * @param executor\n     *  - `en` executer that has `cancel` and `close` callback.\n     *  - `ja` キャンセル/クローズ 実行コールバックを指定\n     * @param linkedTokens\n     *  - `en` relating already made [[CancelToken]] instance.\n     *        You can attach to the token that to be a cancellation target.\n     *  - `ja` すでに作成された [[CancelToken]] 関連付ける場合に指定\n     *        渡された token はキャンセル対象として紐づけられる\n     */\n    constructor(\n        executor: (cancel: (reason: T) => void, close: () => void) => void,\n        ...linkedTokens: CancelToken[]\n    ) {\n        verify('instanceOf', CancelToken, this);\n        verify('typeOf', 'function', executor);\n\n        const linkedTokenSet = new Set(linkedTokens.filter(t => _tokens.has(t)));\n        let status = CancelTokenState.OPEN;\n        for (const t of linkedTokenSet) {\n            status |= getContext(t).status;\n        }\n\n        const context: CancelTokenContext<T> = {\n            publisher: new EventBroker(),\n            subscriptions: new Set(),\n            reason: undefined,\n            status,\n        };\n        _tokens.set(this, Object.seal(context));\n\n        const cancel = this[_cancel];\n        const close = this[_close];\n        if (status === CancelTokenState.OPEN) {\n            for (const t of linkedTokenSet) {\n                context.subscriptions.add(t.register(cancel.bind(this)));\n                this.register(cancel.bind(t));\n            }\n        }\n\n        executor(cancel.bind(this), close.bind(this));\n    }\n\n    /**\n     * @en Cancellation reason accessor.\n     * @ja キャンセルの原因取得\n     */\n    get reason(): T | undefined {\n        return getContext(this).reason;\n    }\n\n    /**\n     * @en Enable cancellation state accessor.\n     * @ja キャンセル可能か判定\n     */\n    get cancelable(): boolean {\n        return getContext(this).status === CancelTokenState.OPEN;\n    }\n\n    /**\n     * @en Cancellation requested state accessor.\n     * @ja キャンセルを受け付けているか判定\n     */\n    get requested(): boolean {\n        return !!(getContext(this).status & CancelTokenState.REQUESTED);\n    }\n\n    /**\n     * @en Cancellation closed state accessor.\n     * @ja キャンセル受付を終了しているか判定\n     */\n    get closed(): boolean {\n        return !!(getContext(this).status & CancelTokenState.CLOSED);\n    }\n\n    /**\n     * @en `toString` tag override.\n     * @ja `toString` タグのオーバーライド\n     */\n    protected get [Symbol.toStringTag](): 'CancelToken' { return 'CancelToken'; }\n\n    /**\n     * @en Register custom cancellation callback.\n     * @ja キャンセル時のカスタム処理の登録\n     *\n     * @param onCancel\n     *  - `en` cancel operation callback\n     *  - `ja` キャンセルコールバック\n     * @returns\n     *  - `en` `Subscription` instance.\n     *        You can revoke cancellation to call `unsubscribe` method.\n     *  - `ja` `Subscription` インスタンス\n     *        `unsubscribe` メソッドを呼ぶことでキャンセルを無効にすることが可能\n     */\n    public register(onCancel: (reason: T) => unknown): Subscription {\n        const context = getContext(this);\n        if (!this.cancelable) {\n            return invalidSubscription;\n        }\n        return context.publisher.on('cancel', onCancel);\n    }\n\n    /** @internal */\n    private [_cancel](reason: T): void {\n        const context = getContext(this);\n        verify('notNil', reason);\n        if (!this.cancelable) {\n            return;\n        }\n        context.reason = reason;\n        context.status |= CancelTokenState.REQUESTED;\n        for (const s of context.subscriptions) {\n            s.unsubscribe();\n        }\n        context.publisher.publish('cancel', reason);\n        Promise.resolve().then(() => this[_close]());\n    }\n\n    /** @internal */\n    private [_close](): void {\n        const context = getContext(this);\n        if (this.closed) {\n            return;\n        }\n        context.status |= CancelTokenState.CLOSED;\n        for (const s of context.subscriptions) {\n            s.unsubscribe();\n        }\n        context.subscriptions.clear();\n        context.publisher.off();\n    }\n}\n","/* eslint-disable no-global-assign, @typescript-eslint/no-explicit-any */\n\nimport {\n    isFunction,\n    verify,\n    getConfig,\n} from '@cdp/core-utils';\nimport { Subscription } from '@cdp/event-publisher';\nimport { CancelToken } from './cancel-token';\n\ndeclare global {\n\n    interface PromiseConstructor {\n        new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, cancelToken?: CancelToken | null): Promise<T>;\n        resolve<T>(value?: T | PromiseLike<T>, cancelToken?: CancelToken | null): Promise<T>;\n    }\n\n}\n\n/** `Native Promise` constructor */\nconst NativePromise = Promise;\n/** @internal */\nconst _create = Symbol('create');\n/** @internal */\nconst _tokens = new WeakMap<Promise<unknown>, CancelToken>();\n\n/**\n * @en Extended `Promise` class which enabled cancellation. <br>\n *     `Native Promise` constructor is overridden by framework default behaviour.\n * @ja キャンセルを可能にした `Promise` 拡張クラス <br>\n *     既定で `Native Promise` をオーバーライドする.\n */\nclass CancelablePromise<T> extends NativePromise<T> {\n\n    /**\n     * @en Overriding of the default constructor used for generation of an object.\n     * @ja オブジェクトの生成に使われるデフォルトコンストラクタのオーバーライド\n     *\n     * @internal\n     */\n    static get [Symbol.species](): PromiseConstructor { return NativePromise; }\n\n    /**\n     * @en Creates a new resolved promise for the provided value.\n     * @ja 新規に解決済み promise インスタンスを作成\n     *\n     * @internal\n     *\n     * @param value\n     *  - `en` the value transmitted in promise chain.\n     *  - `ja` `Promise` に伝達する値\n     * @param cancelToken\n     *  - `en` [[CancelToken]] instance create from [[CancelToken]].`source()`.\n     *  - `ja` [[CancelToken]].`source()` より作成した [[CancelToken]] インスタンスを指定\n     */\n    static resolve<T>(value?: T | PromiseLike<T>, cancelToken?: CancelToken | null): CancelablePromise<T> {\n        return this[_create](super.resolve(value), cancelToken);\n    }\n\n    /** @internal private construction */\n    private static [_create]<T, TResult1 = T, TResult2 = never>(\n        src: Promise<T>,\n        token?: CancelToken | null,\n        thenArgs?: [\n            ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined,\n            ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined\n        ] | null\n    ): CancelablePromise<TResult1 | TResult2> {\n        verify('instanceOf', NativePromise, src);\n\n        let p: Promise<T | TResult1 | TResult2>;\n        if (!(token instanceof CancelToken)) {\n            p = src;\n        } else if (thenArgs && (!isFunction(thenArgs[0]) || isFunction(thenArgs[1]))) {\n            p = src;\n        } else if (token.cancelable) {\n            let s: Subscription;\n            p = new NativePromise((resolve, reject) => {\n                s = token.register(reject);\n                super.prototype.then.call(src, resolve, reject);\n            });\n            const dispose = (): void => {\n                s.unsubscribe();\n                _tokens.delete(p);\n            };\n            p.then(dispose, dispose);\n        } else if (token.requested) {\n            p = super.reject(token.reason);\n        } else if (token.closed) {\n            p = src;\n        } else {\n            throw new Error('Unexpected Exception');\n        }\n\n        if (thenArgs) {\n            p = super.prototype.then.apply(p, thenArgs);\n        }\n        if (token && token.cancelable) {\n            _tokens.set(p, token);\n        }\n\n        p instanceof this || Object.setPrototypeOf(p, this.prototype);\n\n        return p as CancelablePromise<TResult1 | TResult2>;\n    }\n\n    /**\n     * constructor\n     *\n     * @param executor\n     *  - `en` A callback used to initialize the promise. This callback is passed two arguments `resolve` and `reject`.\n     *  - `ja` promise の初期化に使用するコールバックを指定. `resolve` と `reject` の2つの引数を持つ\n     * @param cancelToken\n     *  - `en` [[CancelToken]] instance create from [[CancelToken]].`source()`.\n     *  - `ja` [[CancelToken]].`source()` より作成した [[CancelToken]] インスタンスを指定\n     */\n    constructor(\n        executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void,\n        cancelToken?: CancelToken | null\n    ) {\n        super(executor);\n        return CancelablePromise[_create](this, cancelToken);\n    }\n\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     *\n     * @internal\n     *\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> {\n        return CancelablePromise[_create](this, _tokens.get(this), [onfulfilled, onrejected]);\n    }\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     *\n     * @internal\n     *\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult2 = never>(onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<T | TResult2> {\n        return this.then(undefined, onrejected);\n    }\n\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). <br>\n     * The resolved value cannot be modified from the callback.\n     *\n     * @internal\n     *\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n        return CancelablePromise[_create](super.finally(onfinally), _tokens.get(this));\n    }\n\n}\n\n/**\n * @en Switch the global `Promise` constructor `Native Promise` or [[CancelablePromise]]. <br>\n *     `Native Promise` constructor is overridden by framework default behaviour.\n * @ja グローバル `Promise` コンストラクタを `Native Promise` または [[CancelablePromise]] に切り替え <br>\n *     既定で `Native Promise` をオーバーライドする.\n *\n * @param enable\n *  - `en` `true`: use [[CancelablePromise]] /  `false`: use `Native Promise`\n *  - `ja` `true`: [[CancelablePromise]] を使用 / `false`: `Native Promise` を使用\n */\nexport function extendPromise(enable: boolean): PromiseConstructor {\n    if (enable) {\n        Promise = CancelablePromise;\n    } else {\n        Promise = NativePromise;\n    }\n    return Promise;\n}\n\n/** @internal global config options */\ninterface GlobalConfig {\n    noAutomaticNativeExtend: boolean;\n}\n\n// default: automatic native promise override.\nextendPromise(!getConfig<GlobalConfig>().noAutomaticNativeExtend);\n\nexport {\n    CancelablePromise,\n    CancelablePromise as Promise,\n};\n","/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\nimport { isObject, isString } from '@cdp/core-utils';\nimport { CancelToken, CancelTokenSource } from './cancel-token';\n\n/**\n * @en Cancelable base option definition.\n * @ja キャンセル可能な基底オプション\n */\nexport interface Cancelable {\n    cancel?: CancelToken;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Wait for promises done. <br>\n *     While control will be returned immediately when `Promise.all()` fails, but this mehtod waits for including failure.\n * @ja `Promise` オブジェクトの終了まで待機 <br>\n *     `Promise.all()` は失敗するとすぐに制御を返すのに対し、失敗も含めて待つ `Promise` オブジェクトを返却\n *\n * @param promises\n *  - `en` Promise instance array\n *  - `ja` Promise インスタンスの配列を指定\n */\nexport function wait(promises: Promise<unknown>[]): Promise<unknown[]> {\n    const safePromises = promises.map((promise) => promise.catch((e) => e));\n    return Promise.all(safePromises);\n}\n\n/**\n * @en Cancellation checker method. <br>\n *     It's practicable by `async function`.\n * @ja キャンセルチェッカー <br>\n *     `async function` で使用可能\n *\n * @example <br>\n *\n * ```ts\n *  async function someFunc(token: CancelToken): Promise<{}> {\n *    await checkCanceled(token);\n *    return {};\n *  }\n * ```\n *\n * @param token\n *  - `en` [[CancelToken]] reference. (enable `undefined`)\n *  - `ja` [[CancelToken]] を指定 (undefined 可)\n */\nexport function checkCanceled(token: CancelToken | undefined): Promise<void> {\n    return Promise.resolve(undefined, token);\n}\n\n/** @internal */\nconst _regexCancelLikeString = /(abort|cancel)/im;\n\n/**\n * @en Presume whether it's a canceled error.\n * @ja キャンセルされたエラーであるか推定\n *\n * @param error\n *  - `en` an error object handled in `catch` block.\n *  - `ja` `catch` 節などで補足したエラーを指定\n */\nexport function isChancelLikeError(error: unknown): boolean {\n    if (null == error) {\n        return false;\n    } else if (isString(error)) {\n        return _regexCancelLikeString.test(error);\n    } else if (isObject(error)) {\n        return _regexCancelLikeString.test((error as Error).message);\n    } else {\n        return false;\n    }\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en The class manages lumping multiple `Promise` objects. <br>\n *     It's possible to make them cancel more than one `Promise` which handles different [[CancelToken]] by lumping.\n * @ja 複数 `Promise` オブジェクトを一括管理するクラス <br>\n *     異なる [[CancelToken]] を扱う複数の `Promise` を一括でキャンセルさせることが可能\n */\nexport class PromiseManager {\n    // eslint-disable-next-line func-call-spacing\n    private readonly _pool = new Map<Promise<unknown>, ((reason: unknown) => unknown) | undefined>();\n\n    /**\n     * @en Add a `Promise` object under the management.\n     * @ja `Promise` オブジェクトを管理下に追加\n     *\n     * @param promise\n     *  - `en` any `Promise` instance is available.\n     *  - `ja` 任意の `Promise` インスタンス\n     * @param cancelSource\n     *  - `en` [[CancelTokenSource]] instance made by `CancelToken.source()`.\n     *  - `ja` `CancelToken.source()` で生成される [[CancelTokenSource]] インスタンス\n     * @returns\n     *  - `en` return the same instance of input `promise` instance.\n     *  - `ja` 入力した `promise` と同一インスタンスを返却\n     */\n    public add<T>(promise: Promise<T>, cancelSource?: CancelTokenSource): Promise<T> {\n        this._pool.set(promise, cancelSource && cancelSource.cancel);\n\n        const always = () => {\n            this._pool.delete(promise);\n            if (cancelSource) {\n                cancelSource.close();\n            }\n        };\n\n        promise\n            .then(always, always);\n\n        return promise;\n    }\n\n    /**\n     * @en Released all instances under the management.\n     * @ja 管理対象を破棄\n     */\n    public release(): void {\n        this._pool.clear();\n    }\n\n    /**\n     * @en Return `promise` array from under the management.\n     * @ja 管理対象の Promise を配列で取得\n     */\n    public promises(): Promise<unknown>[] {\n        return [...this._pool.keys()];\n    }\n\n    /**\n     * @en Call `Promise.all()` for under the management.\n     * @ja 管理対象に対して `Promise.all()`\n     */\n    public all() {\n        return Promise.all(this.promises());\n    }\n\n    /**\n     * @en Call `Promise.race()` for under the management.\n     * @ja 管理対象に対して `Promise.race()`\n     */\n    public race() {\n        return Promise.race(this.promises());\n    }\n\n    /**\n     * @en Call [[wait]]() for under the management.\n     * @ja 管理対象に対して [[wait]]()\n     */\n    public wait() {\n        return wait(this.promises());\n    }\n\n    /**\n     * @en Invoke `cancel` message for under the management promises.\n     * @ja 管理対象の `Promise` に対してキャンセルを発行\n     *\n     * @param reason\n     *  - `en` arguments for `cancelSource`\n     *  - `ja` `cancelSource` に渡される引数\n     * @returns\n     *  - `en` `Promise` instance which wait by until cancellation completion.\n     *  - `ja` キャンセル完了まで待機する [[Promise]] インスタンス\n     */\n    public abort<T>(reason?: T): Promise<unknown[]> {\n        for (const canceler of this._pool.values()) {\n            if (canceler) {\n                canceler(\n                    (null != reason) ? reason : new Error('abort')\n                );\n            }\n        }\n        return wait(this.promises());\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    isString,\n    isSymbol,\n    className,\n} from '@cdp/core-utils';\nimport { EventBroker } from '@cdp/event-publisher';\n\n/** @internal EventBrokerProxy */\nexport class EventBrokerProxy<Event extends {}> {\n    private _broker?: EventBroker<Event>;\n    public get(): EventBroker<Event> {\n        return this._broker || (this._broker = new EventBroker());\n    }\n}\n\n/** @internal */\nexport const _internal = Symbol('internal');\n/** @internal */\nexport const _notify = Symbol('notify');\n/** @internal */\nexport const _stockChange = Symbol('stock-change');\n/** @internal */\nexport const _notifyChanges = Symbol('notify-changes');\n\n/** @internal */\nexport function verifyObservable(x: any): void | never {\n    if (!x || !x[_internal]) {\n        throw new TypeError(`The object passed is not an IObservable.`);\n    }\n}\n\n/** @internal */\nexport function verifyValidKey(key: unknown): void | never {\n    if (isString(key) || isSymbol(key)) {\n        return;\n    }\n    throw new TypeError(`Type of ${className(key)} is not a valid key.`);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    NonFunctionPropertyNames,\n    isString,\n    isArray,\n    verify,\n    post,\n    deepMerge,\n} from '@cdp/core-utils';\nimport { Subscription } from '@cdp/event-publisher';\nimport {\n    EventBrokerProxy,\n    _internal,\n    _notify,\n    _stockChange,\n    _notifyChanges,\n    verifyObservable,\n} from './internal';\nimport { ObservableState, IObservable } from './common';\n\n/** @internal */\ninterface InternalProps {\n    state: ObservableState;\n    readonly changeMap: Map<PropertyKey, any>;\n    readonly broker: EventBrokerProxy<any>;\n}\n\n/** @internal */\nconst _proxyHandler: ProxyHandler<ObservableObject> = {\n    set(target, p, value, receiver) {\n        if (!isString(p)) {\n            return Reflect.set(target, p, value, receiver);\n        }\n        const oldValue = target[p];\n        if (ObservableState.DISABLED !== target[_internal].state && value !== oldValue) {\n            target[_stockChange](p, oldValue);\n        }\n        return Reflect.set(target, p, value, receiver);\n    },\n};\nObject.freeze(_proxyHandler);\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Observable key type definition.\n * @ja 購読可能なキーの型定義\n */\nexport type ObservableKeys<T extends ObservableObject> = NonFunctionPropertyNames<T>;\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en The object class which change can be observed.\n * @ja オブジェクトの変更を監視できるオブジェクトクラス\n *\n * @example <br>\n *\n * - Basic Usage\n *\n * ```ts\n * class Example extends ObservableObject {\n *   public a: number = 0;\n *   public b: number = 0;\n *   public get sum(): number {\n *       return this.a + this.b;\n *   }\n * }\n *\n * const observable = new Example();\n *\n * function onNumChange(newValue: number, oldValue: number, key: string) {\n *   console.log(`${key} changed from ${oldValue} to ${newValue}.`);\n * }\n * observable.on(['a', 'b'], onNumChange);\n *\n * // update\n * observable.a = 100;\n * observable.b = 200;\n *\n * // console out from `async` event loop.\n * // => 'a changed from 0 to 100.'\n * // => 'b changed from 0 to 200.'\n *\n * :\n *\n * function onSumChange(newValue: number, oldValue: number) {\n *   console.log(`sum changed from ${oldValue} to ${newVaue}.`);\n * }\n * observable.on('sum', onSumChange);\n *\n * // update\n * observable.a = 100; // nothing reaction because of no change properties.\n * observable.a = 200;\n *\n * // console out from `async` event loop.\n * // => 'sum changed from 300 to 400.'\n * ```\n */\nexport abstract class ObservableObject implements IObservable {\n    /** @internal */\n    private readonly [_internal]: InternalProps;\n\n    /**\n     * constructor\n     *\n     * @param state\n     *  - `en` initial state. default: [[ObservableState.ACTIVE]]\n     *  - `ja` 初期状態 既定: [[ObservableState.ACTIVE]]\n     */\n    constructor(state = ObservableState.ACTIVE) {\n        verify('instanceOf', ObservableObject, this);\n        const internal: InternalProps = {\n            state,\n            changeMap: new Map(),\n            broker: new EventBrokerProxy<this>(),\n        };\n        Object.defineProperty(this, _internal, { value: Object.seal(internal) });\n        return new Proxy(this, _proxyHandler);\n    }\n\n///////////////////////////////////////////////////////////////////////\n// implements: IObservable\n\n    /**\n     * @en Subscrive property change(s).\n     * @ja プロパティ変更購読設定\n     *\n     * @param property\n     *  - `en` target property.\n     *  - `ja` 対象のプロパティ\n     * @param listener\n     *  - `en` callback function of the property change.\n     *  - `ja` プロパティ変更通知コールバック関数\n     */\n    on<K extends ObservableKeys<this>>(property: K | K[], listener: (newValue: this[K], oldValue: this[K], key: K) => any): Subscription {\n        verifyObservable(this);\n        const { changeMap, broker } = this[_internal];\n        const result = broker.get().on(property, listener);\n        if (0 < changeMap.size) {\n            const props = isArray(property) ? property : [property];\n            for (const prop of props) {\n                changeMap.has(prop) || changeMap.set(prop, this[prop]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @en Unsubscribe property change(s).\n     * @ja プロパティ変更購読解除\n     *\n     * @param property\n     *  - `en` target property.\n     *         When not set this parameter, everything is released.\n     *  - `ja` 対象のプロパティ\n     *         指定しない場合はすべて解除\n     * @param listener\n     *  - `en` callback function of the property change.\n     *         When not set this parameter, all same `channel` listeners are released.\n     *  - `ja` プロパティ変更通知コールバック関数\n     *         指定しない場合は同一 `channel` すべてを解除\n     */\n    off<K extends ObservableKeys<this>>(property?: K | K[], listener?: (newValue: this[K], oldValue: this[K], key: K) => any): void {\n        verifyObservable(this);\n        this[_internal].broker.get().off(property, listener);\n    }\n\n    /**\n     * @en Suspend or disable the event observation state.\n     * @ja イベント購読状態のサスペンド\n     *\n     * @param noRecord\n     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when [[resume]]() callded. (default)\n     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, [[resume]]() 時に発火する (既定)\n     */\n    suspend(noRecord = false): this {\n        verifyObservable(this);\n        this[_internal].state = noRecord ? ObservableState.DISABLED : ObservableState.SUSEPNDED;\n        if (noRecord) {\n            this[_internal].changeMap.clear();\n        }\n        return this;\n    }\n\n    /**\n     * @en Resume the event observation state.\n     * @ja イベント購読状態のリジューム\n     */\n    resume(): this {\n        verifyObservable(this);\n        const internal = this[_internal];\n        if (ObservableState.ACTIVE !== internal.state) {\n            internal.state = ObservableState.ACTIVE;\n            post(() => this[_notifyChanges]());\n        }\n        return this;\n    }\n\n    /**\n     * @en observation state\n     * @ja 購読可能状態\n     */\n    getObservableState(): ObservableState {\n        verifyObservable(this);\n        return this[_internal].state;\n    }\n\n///////////////////////////////////////////////////////////////////////\n// static methods:\n\n    /**\n     * @en Create [[ObservableObject]] from any object.\n     * @ja 任意のオブジェクトから [[ObservableObject]] を生成\n     *\n     * @example <br>\n     *\n     * ```ts\n     * const observable = ObservableObject.from({ a: 1, b: 1 });\n     * function onNumChange(newValue: number, oldValue: number, key: string) {\n     *   console.log(`${key} changed from ${oldValue} to ${newValue}.`);\n     * }\n     * observable.on(['a', 'b'], onNumChange);\n     *\n     * // update\n     * observable.a = 100;\n     * observable.b = 200;\n     *\n     * // console out from `async` event loop.\n     * // => 'a changed from 1 to 100.'\n     * // => 'b changed from 1 to 200.'\n     * ```\n     */\n    public static from<T extends {}>(src: T): ObservableObject & T {\n        const observable = deepMerge(new class extends ObservableObject { }(ObservableState.DISABLED), src);\n        observable.resume();\n        return observable;\n    }\n\n///////////////////////////////////////////////////////////////////////\n// protected mehtods:\n\n    /**\n     * @en Force notify property change(s) in spite of active state.\n     * @ja アクティブ状態にかかわらず強制的にプロパティ変更通知を発行\n     */\n    protected notify(...properties: string[]): void {\n        verifyObservable(this);\n        if (0 === properties.length) {\n            return;\n        }\n        const { changeMap } = this[_internal];\n        const keyValue = new Map<PropertyKey, [any, any]>();\n        for (const key of properties) {\n            const newValue = this[key];\n            const oldValue = changeMap.has(key) ? changeMap.get(key) : newValue;\n            keyValue.set(key, [newValue, oldValue]);\n        }\n        0 < keyValue.size && this[_notify](keyValue);\n    }\n\n///////////////////////////////////////////////////////////////////////\n// private mehtods:\n\n    /** @internal */\n    private [_stockChange](p: string, oldValue: any): void {\n        const { state, changeMap, broker } = this[_internal];\n        if (0 === changeMap.size) {\n            changeMap.set(p, oldValue);\n            for (const k of broker.get().channels()) {\n                changeMap.has(k) || changeMap.set(k, this[k]);\n            }\n            if (ObservableState.ACTIVE === state) {\n                post(() => this[_notifyChanges]());\n            }\n        } else {\n            changeMap.has(p) || changeMap.set(p, oldValue);\n        }\n    }\n\n    /** @internal */\n    private [_notifyChanges](): void {\n        const { state, changeMap } = this[_internal];\n        if (ObservableState.ACTIVE !== state) {\n            return;\n        }\n        const keyValuePairs = new Map<PropertyKey, [any, any]>();\n        for (const [key, oldValue] of changeMap) {\n            const curValue = this[key];\n            if (oldValue !== curValue) {\n                keyValuePairs.set(key, [curValue, oldValue]);\n            }\n        }\n        this[_notify](keyValuePairs);\n    }\n\n    /** @internal */\n    private [_notify](keyValue: Map<PropertyKey, [any, any]>): void {\n        const { changeMap, broker } = this[_internal];\n        changeMap.clear();\n        for (const [key, values] of keyValue) {\n            (broker.get() as any).publish(key, ...values, key);\n        }\n    }\n}\n","/* eslint-disable prefer-rest-params, @typescript-eslint/no-explicit-any */\n\nimport {\n    Writable,\n    isNumber,\n    verify,\n    post,\n} from '@cdp/core-utils';\nimport { Subscription } from '@cdp/event-publisher';\nimport {\n    EventBrokerProxy,\n    _internal,\n    _notify,\n    _stockChange,\n    _notifyChanges,\n    verifyObservable,\n} from './internal';\nimport { ObservableState, IObservable } from './common';\n\n/**\n * @en Array change type information. <br>\n *     The value is suitable for the number of fluctuation of the element.\n * @ja 配列変更通知のタイプ <br>\n *     値は要素の増減数に相当\n *\n */\nexport const enum ArrayChangeType {\n    REMOVE = -1,\n    UPDATE = 0,\n    INSERT = 1,\n}\n\n/**\n * @en Array change record information.\n * @ja 配列変更情報\n */\nexport interface ArrayChangeRecord<T> {\n    /**\n     * @en The change type information.\n     * @ja 配列変更情報の識別子\n     */\n    readonly type: ArrayChangeType;\n\n    /**\n     * @en The change type information. <br>\n     *     ※ [Attention] The index will be different from the actual location when array size changed because that determines element operation unit.\n     * @ja 変更が発生した配列内の位置の index <br>\n     *     ※ [注意] オペレーション単位の index となり, 要素が増減する場合は実際の位置と異なることがある\n     */\n    readonly index: number;\n\n    /**\n     * @en New element's value.\n     * @ja 要素の新しい値\n     */\n    readonly newValue?: T;\n\n    /**\n     * @en Old element's value.\n     * @ja 要素の古い値\n     */\n    readonly oldValue?: T;\n}\ntype MutableChangeRecord<T> = Writable<ArrayChangeRecord<T>>;\n\n//__________________________________________________________________________________________________//\n\n/** @internal */\ninterface IArrayChangeEvent<T> {\n    '@': [ArrayChangeRecord<T>[]];\n}\n\n/** @internal */\ninterface InternalProps<T = any> {\n    state: ObservableState;\n    byMethod: boolean;\n    records: MutableChangeRecord<T>[];\n    readonly indexes: Set<number>;\n    readonly broker: EventBrokerProxy<IArrayChangeEvent<T>>;\n}\n\n/** @internal */\nconst _proxyHandler: ProxyHandler<ObservableArray> = {\n    defineProperty(target, p, attributes) {\n        const internal = target[_internal];\n        if (ObservableState.DISABLED === internal.state || internal.byMethod || !Object.prototype.hasOwnProperty.call(attributes, 'value')) {\n            return Reflect.defineProperty(target, p, attributes);\n        }\n        const oldValue = target[p];\n        const newValue = attributes.value;\n        // eslint-disable-next-line eqeqeq\n        if ('length' === p && newValue != oldValue) { // Do NOT use strict inequality (!==)\n            const oldLength = oldValue >>> 0;\n            const newLength = newValue >>> 0;\n            const stock = (): void => {\n                const scrap = newLength < oldLength && target.slice(newLength);\n                if (scrap) { // newLength < oldLength\n                    for (let i = oldLength; --i >= newLength;) {\n                        target[_stockChange](ArrayChangeType.REMOVE, i, undefined, scrap[i - newLength]);\n                    }\n                } else {            // oldLength < newLength\n                    for (let i = oldLength; i < newLength; i++) {\n                        target[_stockChange](ArrayChangeType.INSERT, i /*, undefined, undefined */);\n                    }\n                }\n            };\n            const result = Reflect.defineProperty(target, p, attributes);\n            result && stock();\n            return result;\n        } else if (newValue !== oldValue && isValidArrayIndex(p)) {\n            const i = p as any >>> 0;\n            const type: ArrayChangeType = Number(i >= target.length); // INSERT or UPDATE\n            const result = Reflect.defineProperty(target, p, attributes);\n            result && target[_stockChange](type, i, newValue, oldValue);\n            return result;\n        } else {\n            return Reflect.defineProperty(target, p, attributes);\n        }\n    },\n    deleteProperty(target, p) {\n        const internal = target[_internal];\n        if (ObservableState.DISABLED === internal.state || internal.byMethod || !Object.prototype.hasOwnProperty.call(target, p)) {\n            return Reflect.deleteProperty(target, p);\n        }\n        const oldValue = target[p];\n        const result = Reflect.deleteProperty(target, p);\n        result && isValidArrayIndex(p) && target[_stockChange](ArrayChangeType.UPDATE, p as any >>> 0, undefined, oldValue);\n        return result;\n    },\n};\nObject.freeze(_proxyHandler);\n\n/** @internal valid array index helper */\nfunction isValidArrayIndex<T>(index: any): boolean {\n    const s = String(index);\n    const n = Math.trunc(s as any);\n    return String(n) === s && 0 <= n && n < 0xFFFFFFFF;\n}\n\n/** @internal helper for index management */\nfunction findRelatedChangeIndex<T>(records: MutableChangeRecord<T>[], type: ArrayChangeType, index: number): number {\n    const checkType = type === ArrayChangeType.INSERT\n        ? (t: ArrayChangeType) => t === ArrayChangeType.REMOVE\n        : (t: ArrayChangeType) => t !== ArrayChangeType.REMOVE\n        ;\n\n    for (let i = records.length; --i >= 0;) {\n        const value = records[i];\n        if (value.index === index && checkType(value.type)) {\n            return i;\n        } else if (value.index < index && Boolean(value.type)) { // REMOVE or INSERT\n            index -= value.type;\n        }\n    }\n    return -1;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en The array class which change can be observed.\n * @ja 変更監視可能な配列クラス\n *\n * @example <br>\n *\n * - Basic Usage\n *\n * ```ts\n * const obsArray = ObservableArray.from(['a', 'b', 'c']);\n *\n * function onChangeArray(records: ArrayChangeRecord[]) {\n *   console.log(records);\n *   //  [\n *   //    { type: 1, index: 3, newValue: 'x', oldValue: undefined },\n *   //    { type: 1, index: 4, newValue: 'y', oldValue: undefined },\n *   //    { type: 1, index: 5, newValue: 'z', oldValue: undefined }\n *   //  ]\n * }\n * obsArray.on(onChangeArray);\n *\n * function addXYZ() {\n *   obsArray.push('x', 'y', 'z');\n * }\n * ```\n */\nexport class ObservableArray<T = any> extends Array<T> implements IObservable {\n    /** @internal */\n    private readonly [_internal]: InternalProps<T>;\n\n    /** @final constructor */\n    private constructor() {\n        super(...arguments);\n        verify('instanceOf', ObservableArray, this);\n        const internal: InternalProps<T> = {\n            state: ObservableState.ACTIVE,\n            byMethod: false,\n            records: [],\n            indexes: new Set(),\n            broker: new EventBrokerProxy<IArrayChangeEvent<T>>(),\n        };\n        Object.defineProperty(this, _internal, { value: Object.seal(internal) });\n        const argLength = arguments.length;\n        if (1 === argLength && isNumber(arguments[0])) {\n            const len = arguments[0] >>> 0;\n            for (let i = 0; i < len; i++) {\n                this[_stockChange](ArrayChangeType.INSERT, i /*, undefined */);\n            }\n        } else if (0 < argLength) {\n            for (let i = 0; i < argLength; i++) {\n                this[_stockChange](ArrayChangeType.INSERT, i, arguments[i]);\n            }\n        }\n        return new Proxy(this, _proxyHandler);\n    }\n\n///////////////////////////////////////////////////////////////////////\n// implements: IObservable\n\n    /**\n     * @en Subscrive array change(s).\n     * @ja 配列変更購読設定\n     *\n     * @param listener\n     *  - `en` callback function of the array change.\n     *  - `ja` 配列変更通知コールバック関数\n     */\n    on(listener: (records: ArrayChangeRecord<T>[]) => any): Subscription {\n        verifyObservable(this);\n        return this[_internal].broker.get().on('@', listener);\n    }\n\n    /**\n     * @en Unsubscribe array change(s).\n     * @ja 配列変更購読解除\n     *\n     * @param listener\n     *  - `en` callback function of the array change.\n     *         When not set this parameter, all same `channel` listeners are released.\n     *  - `ja` 配列変更通知コールバック関数\n     *         指定しない場合は同一 `channel` すべてを解除\n     */\n    off(listener?: (records: ArrayChangeRecord<T>[]) => any): void {\n        verifyObservable(this);\n        this[_internal].broker.get().off('@', listener);\n    }\n\n    /**\n     * @en Suspend or disable the event observation state.\n     * @ja イベント購読状態のサスペンド\n     *\n     * @param noRecord\n     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when [[resume]]() callded. (default)\n     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, [[resume]]() 時に発火する (既定)\n     */\n    suspend(noRecord = false): this {\n        verifyObservable(this);\n        this[_internal].state = noRecord ? ObservableState.DISABLED : ObservableState.SUSEPNDED;\n        if (noRecord) {\n            this[_internal].records = [];\n        }\n        return this;\n    }\n\n    /**\n     * @en Resume of the event subscription state.\n     * @ja イベント購読状態のリジューム\n     */\n    resume(): this {\n        verifyObservable(this);\n        const internal = this[_internal];\n        if (ObservableState.ACTIVE !== internal.state) {\n            internal.state = ObservableState.ACTIVE;\n            post(() => this[_notifyChanges]());\n        }\n        return this;\n    }\n\n    /**\n     * @en observation state\n     * @ja 購読可能状態\n     */\n    getObservableState(): ObservableState {\n        verifyObservable(this);\n        return this[_internal].state;\n    }\n\n///////////////////////////////////////////////////////////////////////\n// override: Array methods\n\n    /**\n     * Sorts an array.\n     * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n     */\n    sort(comparator?: (lhs: T, rhs: T) => number): this {\n        verifyObservable(this);\n        const internal = this[_internal];\n        const old = Array.from(this);\n        internal.byMethod = true;\n        const result = super.sort(comparator);\n        internal.byMethod = false;\n        if (ObservableState.DISABLED !== internal.state) {\n            const len = old.length;\n            for (let i = 0; i < len; i++) {\n                const oldValue = old[i];\n                const newValue = this[i];\n                if (newValue !== oldValue) {\n                    this[_stockChange](ArrayChangeType.UPDATE, i, newValue, oldValue);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     */\n    splice(start: number, deleteCount?: number): ObservableArray<T>;\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param items Elements to insert into the array in place of the deleted elements.\n     */\n    splice(start: number, deleteCount: number, ...items: T[]): ObservableArray<T>;\n    splice(start: number, deleteCount?: number, ...items: T[]): ObservableArray<T> {\n        verifyObservable(this);\n        const internal = this[_internal];\n        const oldLen = this.length;\n        internal.byMethod = true;\n        const result = (super.splice as any)(...arguments) as ObservableArray<T>;\n        internal.byMethod = false;\n        if (ObservableState.DISABLED !== internal.state) {\n            start = Math.trunc(start);\n            const from = start < 0 ? Math.max(oldLen + start, 0) : Math.min(start, oldLen);\n            for (let i = result.length; --i >= 0;) {\n                this[_stockChange](ArrayChangeType.REMOVE, from + i, undefined, result[i]);\n            }\n            const len = items.length;\n            for (let i = 0; i < len; i++) {\n                this[_stockChange](ArrayChangeType.INSERT, from + i, items[i]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Removes the first element from an array and returns it.\n     */\n    shift(): T | undefined {\n        verifyObservable(this);\n        const internal = this[_internal];\n        const oldLen = this.length;\n        internal.byMethod = true;\n        const result = super.shift();\n        internal.byMethod = false;\n        if (ObservableState.DISABLED !== internal.state && this.length < oldLen) {\n            this[_stockChange](ArrayChangeType.REMOVE, 0, undefined, result);\n        }\n        return result;\n    }\n\n    /**\n     * Inserts new elements at the start of an array.\n     * @param items  Elements to insert at the start of the Array.\n     */\n    unshift(...items: T[]): number {\n        verifyObservable(this);\n        const internal = this[_internal];\n        internal.byMethod = true;\n        const result = super.unshift(...items);\n        internal.byMethod = false;\n        if (ObservableState.DISABLED !== internal.state) {\n            const len = items.length;\n            for (let i = 0; i < len; i++) {\n                this[_stockChange](ArrayChangeType.INSERT, i, items[i]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): ObservableArray<U> {\n        /*\n         * [NOTE] original implement is very very high-cost.\n         *        so it's converted native Array once, and restored.\n         *\n         * return (super.map as any)(...arguments);\n         */\n        return ObservableArray.from([...this].map(callbackfn, thisArg));\n    }\n\n///////////////////////////////////////////////////////////////////////\n// private mehtods:\n\n    /** @internal */\n    private [_stockChange](type: ArrayChangeType, index: number, newValue?: T, oldValue?: T): void {\n        const { state, indexes, records } = this[_internal];\n        const rci = indexes.has(index) ? findRelatedChangeIndex(records, type, index) : -1;\n        const len = records.length;\n        if (rci >= 0) {\n            const rct = records[rci].type;\n            if (!rct /* UPDATE */) {\n                const prevRecord = records.splice(rci, 1)[0];\n                // UPDATE => UPDATE : UPDATE\n                // UPDATE => REMOVE : INSERT\n                this[_stockChange](type, index, newValue, prevRecord.oldValue);\n            } else {\n                for (let r, i = len; --i > rci;) {\n                    r = records[i];\n                    (r.index >= index) && (r.index -= rct);\n                }\n                const prevRecord = records.splice(rci, 1)[0];\n                if (type !== ArrayChangeType.REMOVE) {\n                    // INSERT => UPDATE : INSERT\n                    // REMOVE => INSERT : UPDATE\n                    this[_stockChange](Number(!type), index, newValue, prevRecord.oldValue);\n                }\n            }\n            return;\n        }\n        indexes.add(index);\n        records[len] = { type, index, newValue, oldValue };\n        if (ObservableState.ACTIVE === state && 0 === len) {\n            post(() => this[_notifyChanges]());\n        }\n    }\n\n    /** @internal */\n    private [_notifyChanges](): void {\n        const { state, records } = this[_internal];\n        if (ObservableState.ACTIVE !== state || 0 === records.length) {\n            return;\n        }\n        for (const r of records) {\n            Object.freeze(r);\n        }\n        this[_notify](Object.freeze(records) as ArrayChangeRecord<T>[]);\n        this[_internal].records = [];\n    }\n\n    /** @internal */\n    private [_notify](records: ArrayChangeRecord<T>[]): void {\n        const internal = this[_internal];\n        internal.indexes.clear();\n        internal.broker.get().publish('@', records);\n    }\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * Override return type of prototype methods\n */\nexport interface ObservableArray<T> {\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    concat(...items: T[][]): ObservableArray<T>;\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    concat(...items: (T | T[])[]): ObservableArray<T>;\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): this;\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array.\n     */\n    slice(start?: number, end?: number): ObservableArray<T>;\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): ObservableArray<S>;\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): ObservableArray<T>;\n}\n\n/**\n * Override return type of static methods\n */\nexport declare namespace ObservableArray { // eslint-disable-line @typescript-eslint/no-namespace\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    function from<T>(arrayLike: ArrayLike<T> | Iterable<T>): ObservableArray<T>;\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    function from<T, U>(arrayLike: ArrayLike<T> | Iterable<T>, mapfn: (this: void, v: T, k: number) => U, thisArg?: undefined): ObservableArray<U>;\n    function from<X, T, U>(arrayLike: ArrayLike<T> | Iterable<T>, mapfn: (this: X, v: T, k: number) => U, thisArg: X): ObservableArray<U>;\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    function of<T>(...items: T[]): ObservableArray<T>;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    PlainObject,\n    Keys,\n    Types,\n    KeyToType,\n    deepEqual,\n    isEmptyObject,\n    fromTypedData,\n    dropUndefined,\n    restoreNil,\n} from '@cdp/core-utils';\nimport { Subscription, EventBroker } from '@cdp/event-publisher';\nimport {\n    Cancelable,\n    checkCanceled as cc,\n} from '@cdp/promise';\nimport {\n    StorageDataTypeList,\n    StorageInputDataTypeList,\n    IStorageOptions,\n    IStorageDataOptions,\n    IStorageDataReturnType,\n    IStorageEventCallback,\n    IStorage,\n} from './interfaces';\n\n/** MemoryStorage I/O options */\nexport type MemoryStorageOptions<K extends Keys<StorageDataTypeList>> = IStorageDataOptions<StorageDataTypeList, K>;\n/** MemoryStorage return value */\nexport type MemoryStorageResult<K extends Keys<StorageDataTypeList>> = KeyToType<StorageDataTypeList, K>;\n/** MemoryStorage data type */\nexport type MemoryStorageDataTypes = Types<StorageDataTypeList>;\n/** MemoryStorage input data type */\nexport type MemoryStorageInputDataTypes = StorageInputDataTypeList<StorageDataTypeList>;\n/** MemoryStorage event callback */\nexport type MemoryStorageEventCallback = IStorageEventCallback<StorageDataTypeList>;\n\n/** @internal */\ninterface MemoryStorageEvent {\n    '@': [string | null, Types<StorageDataTypeList> | null, Types<StorageDataTypeList> | null];\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Memory storage class. This class doesn't support permaneciation data.\n * @ja メモリーストレージクラス. 本クラスはデータの永続化をサポートしない\n */\nexport class MemoryStorage implements IStorage {\n\n    private readonly _broker = new EventBroker<MemoryStorageEvent>();\n    private _storage: PlainObject = {};\n\n///////////////////////////////////////////////////////////////////////\n// implements: IStorage\n    /**\n     * @en [[IStorage]] kind signature.\n     * @ja [[IStorage]] の種別を表す識別子\n     */\n    get kind(): string {\n        return 'memory';\n    }\n\n    /**\n     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.\n     * @ja キーに対応する値を取得. 存在しない場合は null を返却\n     *\n     * @param key\n     *  - `en` access key\n     *  - `ja` アクセスキー\n     * @param options\n     *  - `en` I/O options\n     *  - `ja` I/O オプション\n     * @returns\n     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.\n     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却\n     */\n    getItem<D extends Types<StorageDataTypeList> = Types<StorageDataTypeList>>(\n        key: string,\n        options?: MemoryStorageOptions<never>\n    ): Promise<IStorageDataReturnType<StorageDataTypeList, D>>;\n\n    /**\n     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.\n     * @ja キーに対応する値を取得. 存在しない場合は null を返却\n     *\n     * @param key\n     *  - `en` access key\n     *  - `ja` アクセスキー\n     * @param options\n     *  - `en` I/O options\n     *  - `ja` I/O オプション\n     * @returns\n     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.\n     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却\n     */\n    getItem<K extends Keys<StorageDataTypeList>>(\n        key: string,\n        options?: MemoryStorageOptions<K>\n    ): Promise<MemoryStorageResult<K> | null>;\n\n    async getItem(key: string, options?: MemoryStorageOptions<any>): Promise<Types<StorageDataTypeList> | null> {\n        options = options || {};\n        await cc(options.cancel);\n\n        // `undefined` → `null`\n        const value = dropUndefined(this._storage[key]);\n        switch (options.dataType) {\n            case 'string':\n                return fromTypedData(value) as string;\n            case 'number':\n                return Number(restoreNil(value));\n            case 'boolean':\n                return Boolean(restoreNil(value));\n            case 'object':\n                return Object(restoreNil(value));\n            default:\n                return restoreNil(value);\n        }\n    }\n\n    /**\n     * @en Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.\n     * @ja キーを指定して値を設定. 存在しない場合は新規に作成\n     *\n     * @param key\n     *  - `en` access key\n     *  - `ja` アクセスキー\n     * @param options\n     *  - `en` I/O options\n     *  - `ja` I/O オプション\n     */\n    async setItem<V extends MemoryStorageInputDataTypes>(key: string, value: V, options?: MemoryStorageOptions<never>): Promise<void> {\n        options = options || {};\n        await cc(options.cancel);\n        const newVal = dropUndefined(value, true);         // `null` or `undefined` → 'null' or 'undefined'\n        const oldVal = dropUndefined(this._storage[key]);  // `undefined` → `null`\n        if (!deepEqual(oldVal, newVal)) {\n            this._storage[key] = newVal;\n            !options.silent && this._broker.publish('@', key, newVal, oldVal);\n        }\n    }\n\n    /**\n     * @en Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.\n     * @ja 指定されたキーに対応する値が存在すれば削除\n     *\n     * @param options\n     *  - `en` storage options\n     *  - `ja` ストレージオプション\n     */\n    async removeItem(key: string, options?: IStorageOptions): Promise<void> {\n        options = options || {};\n        await cc(options.cancel);\n        const oldVal = this._storage[key];\n        if (undefined !== oldVal) {\n            delete this._storage[key];\n            !options.silent && this._broker.publish('@', key, null, oldVal);\n        }\n    }\n\n    /**\n     * @en Empties the list associated with the object of all key/value pairs, if there are any.\n     * @ja すべてのキーに対応する値を削除\n     *\n     * @param options\n     *  - `en` storage options\n     *  - `ja` ストレージオプション\n     */\n    async clear(options?: IStorageOptions): Promise<void> {\n        options = options || {};\n        await cc(options.cancel);\n        if (!isEmptyObject(this._storage)) {\n            this._storage = {};\n            !options.silent && this._broker.publish('@', null, null, null);\n        }\n    }\n\n    /**\n     * @en Returns all entry keys.\n     * @ja すべてのキー一覧を返却\n     *\n     * @param options\n     *  - `en` cancel options\n     *  - `ja` キャンセルオプション\n     */\n    async keys(options?: Cancelable): Promise<string[]> {\n        await cc(options && options.cancel);\n        return Object.keys(this._storage);\n    }\n\n    /**\n     * @en Subscrive event(s).\n     * @ja イベント購読設定\n     *\n     * @param listener\n     *  - `en` callback function.\n     *  - `ja` コールバック関数\n     */\n    on(listener: MemoryStorageEventCallback): Subscription {\n        return this._broker.on('@', listener);\n    }\n\n    /**\n     * @en Unsubscribe event(s).\n     * @ja イベント購読解除\n     *\n     * @param listener\n     *  - `en` callback function.\n     *         When not set this parameter, listeners are released.\n     *  - `ja` コールバック関数\n     *         指定しない場合はすべてを解除\n     */\n    off(listener?: MemoryStorageEventCallback): void {\n        this._broker.off('@', listener);\n    }\n}\n\n// default storage\nexport const memoryStorage = new MemoryStorage();\n","/* eslint-disable no-inner-declarations, @typescript-eslint/no-namespace, @typescript-eslint/no-unused-vars */\n\n/*\n * NOTE: 内部モジュールに `CDP` namespace を使用してしまうと, 外部モジュールでは宣言できなくなる.\n * https://github.com/Microsoft/TypeScript/issues/9611\n */\nnamespace CDP_DECLARE {\n\n    /**\n     * @en Constant definition about range of the result code.\n     * @ja リザルトコードの範囲に関する定数定義\n     */\n    export const enum RESULT_CODE_RANGE {\n        /**\n         * @en The assignable range for the client's local result cord by which expansion is possible.\n         * @ja クライアントが拡張可能なローカルリザルトコードのアサイン可能領域\n         */\n        MAX = 1000,\n        /**\n         * @en Reserved range of framework.\n         * @ja フレームワークの予約領域\n         */\n        RESERVED = 1000,\n    }\n\n    /**\n     * @en The assignment range guideline definition used in the module.\n     * @ja モジュール内で使用するアサイン領域ガイドライン定数定義\n     */\n    export const enum LOCAL_CODE_RANGE_GUIDE {\n        /**\n         * @en The assignment range guideline per 1 module.\n         * @ja 1モジュール当たりに割り当てるアサイン領域ガイドライン\n         */\n        MODULE = 100,\n        /**\n         * @en The assignment range guideline per 1 function.\n         * @ja 1機能当たりに割り当てるアサイン領域ガイドライン\n         */\n        FUNCTION = 20,\n    }\n\n    /**\n     * @en Offset value enumeration for [[RESULT_CODE]]. <br>\n     *     The client can expand a definition in other module.\n     * @ja [[RESULT_CODE]] のオフセット値 <br>\n     *     エラーコード対応するモジュール内で 定義を拡張する.\n     *\n     * @example <br>\n     *\n     * ```ts\n     *  const enum LOCAL_CODE_BASE {\n     *      COMMON      = 0,\n     *      SOMEMODULE  = 1 * LOCAL_CODE_RANGE_GUIDE.FUNCTION,\n     *      SOMEMODULE2 = 2 * LOCAL_CODE_RANGE_GUIDE.FUNCTION,\n     *  }\n     *\n     *  export enum RESULT_CODE {\n     *      ERROR_SOMEMODULE_UNEXPECTED  = DECLARE_ERROR_CODE(RESULT_CODE_BASE.SOMEMODULE, LOCAL_CODE_BASE.SOMEMODULE + 1, \"error unexpected.\"),\n     *      ERROR_SOMEMODULE_INVALID_ARG = DECLARE_ERROR_CODE(RESULT_CODE_BASE.SOMEMODULE, LOCAL_CODE_BASE.SOMEMODULE + 2, \"invalid arguments.\"),\n     *  }\n     *  ASSIGN_RESULT_CODE(RESULT_CODE);\n     * ```\n     */\n    export const enum RESULT_CODE_BASE {\n        COMMON = 0,\n        CDP = 1 * LOCAL_CODE_RANGE_GUIDE.MODULE, // cdp reserved. abs(0 ～ 1000)\n//      MODULE_A = 1 * RESULT_CODE_RANGE.MAX,    // ex) moduleA: abs(1001 ～ 1999)\n//      MODULE_B = 2 * RESULT_CODE_RANGE.MAX,    // ex) moduleB: abs(2001 ～ 2999)\n//      MODULE_C = 3 * RESULT_CODE_RANGE.MAX,    // ex) moduleC: abs(3001 ～ 3999)\n    }\n\n    /**\n     * @en Known CDP module offest definition.\n     * @ja 管轄している CDP モジュールのオフセット定義\n     *\n     * @example <br>\n     *\n     * ```ts\n     * const enum LOCAL_CODE_BASE {\n     *    AJAX = CDP_KNOWN_MODULE.AJAX * LOCAL_CODE_RANGE_GUIDE.FUNCTION,\n     * }\n     *\n     * export enum RESULT_CODE {\n     *   ERROR_AJAX_RESPONSE = DECLARE_ERROR_CODE(RESULT_CODE_BASE.CDP, LOCAL_CODE_BASE.AJAX + 1, 'network error.'),\n     *   ERROR_AJAX_TIMEOUT  = DECLARE_ERROR_CODE(RESULT_CODE_BASE.CDP, LOCAL_CODE_BASE.AJAX + 2, 'request timeout.'),\n     * }\n     * ```\n     */\n    export const enum CDP_KNOWN_MODULE {\n        /** `@cdp/ajax` */\n        AJAX = 1,\n        /** offset for unknown module */\n        OFFSET,\n    }\n\n    /**\n     * @en Common result code for the application.\n     * @ja アプリケーション全体で使用する共通エラーコード定義\n     */\n    export enum RESULT_CODE {\n        /** `en` general success code             <br> `ja` 汎用成功コード                       */\n        SUCCESS = 0,\n        /** `en` general cancel code              <br> `ja` 汎用キャンセルコード                 */\n        ABORT = 1,\n        /** `en` general pending code             <br> `ja` 汎用オペレーション未実行エラーコード */\n        PENDING = 2,\n        /** `en` general success but noop code    <br> `ja` 汎用実行不要コード                   */\n        NOOP = 3,\n        /** `en` general error code               <br> `ja` 汎用エラーコード                     */\n        FAIL = -1,\n        /** `en` general fatal error code         <br> `ja` 汎用致命的エラーコード               */\n        FATAL = -2,\n        /** `en` general not supported error code <br> `ja` 汎用オペレーションエラーコード       */\n        NOT_SUPPORTED = -3,\n    }\n\n    /**\n     * @en Assign declared [[RESULT_CODE]] to root enumeration.\n     *     (It's enable to merge enum in the module system environment.)\n     * @ja 拡張した [[RESULT_CODE]] を ルート enum にアサイン\n     *     モジュールシステム環境においても、enum をマージを可能にする\n     */\n    export function ASSIGN_RESULT_CODE(extend: object): void {\n        Object.assign(RESULT_CODE, extend);\n    }\n\n    /** @internal */\n    const _code2message: { [code: string]: string; } = {\n        '0': 'operation succeeded.',\n        '1': 'operation aborted.',\n        '2': 'operation pending.',\n        '3': 'no operation.',\n        '-1': 'operation failed.',\n        '-2': 'unexpected error occured.',\n        '-3': 'operation not supported.',\n    };\n\n    /**\n     * @en Access to error message map.\n     * @ja エラーメッセージマップの取得\n     *\n     * @internal\n     */\n    export function ERROR_MESSAGE_MAP(): { [code: string]: string; } {\n        return _code2message;\n    }\n\n    /**\n     * @en Generate success code.\n     * @ja 成功コードを生成\n     *\n     * @param base\n     *  - `en` set base offset as [[RESULT_CODE_BASE]]\n     *  - `ja` オフセット値を [[RESULT_CODE_BASE]] として指定\n     * @param code\n     *  - `en` set local code for declaration. ex) '1'\n     *  - `ja` 宣言用のローカルコード値を指定  例) '1'\n     * @param message\n     *  - `en` set error message for help string.\n     *  - `ja` ヘルプストリング用エラーメッセージを指定\n     */\n    export function DECLARE_SUCCESS_CODE(base: RESULT_CODE_BASE, code: number, message?: string): number {\n        return declareResultCode(base, code, message, true);\n    }\n\n    /**\n     * @en Generate error code.\n     * @ja エラーコード生成\n     *\n     * @param base\n     *  - `en` set base offset as [[RESULT_CODE_BASE]]\n     *  - `ja` オフセット値を [[RESULT_CODE_BASE]] として指定\n     * @param code\n     *  - `en` set local code for declaration. ex) '1'\n     *  - `ja` 宣言用のローカルコード値を指定  例) '1'\n     * @param message\n     *  - `en` set error message for help string.\n     *  - `ja` ヘルプストリング用エラーメッセージを指定\n     */\n    export function DECLARE_ERROR_CODE(base: RESULT_CODE_BASE, code: number, message?: string): number {\n        return declareResultCode(base, code, message, false);\n    }\n\n///////////////////////////////////////////////////////////////////////\n// private section:\n\n    /** @internal register for [[RESULT_CODE]] */\n    function declareResultCode(base: RESULT_CODE_BASE, code: number, message: string | undefined, succeeded: boolean): number | never {\n        if (code < 0 || RESULT_CODE_RANGE.MAX <= code) {\n            throw new RangeError(`declareResultCode(), invalid local-code range. [code: ${code}]`);\n        }\n        const signed = succeeded ? 1 : -1;\n        const resultCode = signed * (base as number + code);\n        _code2message[resultCode] = message ? message : (`[CODE: ${resultCode}]`);\n        return resultCode;\n    }\n}\n","import RESULT_CODE              = CDP_DECLARE.RESULT_CODE;\nimport RESULT_CODE_BASE         = CDP_DECLARE.RESULT_CODE_BASE;\nimport RESULT_CODE_RANGE        = CDP_DECLARE.RESULT_CODE_RANGE;\nimport LOCAL_CODE_RANGE_GUIDE   = CDP_DECLARE.LOCAL_CODE_RANGE_GUIDE;\nimport DECLARE_SUCCESS_CODE     = CDP_DECLARE.DECLARE_SUCCESS_CODE;\nimport DECLARE_ERROR_CODE       = CDP_DECLARE.DECLARE_ERROR_CODE;\nimport ASSIGN_RESULT_CODE       = CDP_DECLARE.ASSIGN_RESULT_CODE;\nimport ERROR_MESSAGE_MAP        = CDP_DECLARE.ERROR_MESSAGE_MAP;\n\nconst enum Description {\n    UNKNOWN_ERROR_NAME ='UNKNOWN',\n}\n\nexport {\n    RESULT_CODE,\n    RESULT_CODE_BASE,\n    RESULT_CODE_RANGE,\n    LOCAL_CODE_RANGE_GUIDE,\n    DECLARE_SUCCESS_CODE,\n    DECLARE_ERROR_CODE,\n    ASSIGN_RESULT_CODE,\n};\n\n/**\n * @en Judge fail or not.\n * @ja 失敗判定\n *\n * @param code [[RESULT_CODE]]\n * @returns true: fail result / false: success result\n */\nexport function FAILED(code: number): boolean {\n    return code < 0;\n}\n\n/**\n * @en Judge success or not.\n * @ja 成功判定\n *\n * @param code [[RESULT_CODE]]\n * @returns true: success result / false: fail result\n */\nexport function SUCCEEDED(code: number): boolean {\n    return !FAILED(code);\n}\n\n/**\n * @en Convert to [[RESULT_CODE]] `name` string from [[RESULT_CODE]].\n * @ja [[RESULT_CODE]] を [[RESULT_CODE]] 文字列に変換\n *\n * @param code [[RESULT_CODE]]\n * @param tag  custom tag if needed.\n * @returns name string ex) \"[tag][NOT_SUPPORTED]\"\n */\nexport function toNameString(code: number, tag?: string): string {\n    const prefix = tag ? `[${tag}]` : '';\n    if (RESULT_CODE[code]) {\n        return `${prefix}[${RESULT_CODE[code]}]`;\n    } else {\n        return `${prefix}[${Description.UNKNOWN_ERROR_NAME}]`;\n    }\n}\n\n/**\n * @en Convert to help string from [[RESULT_CODE]].\n * @ja [[RESULT_CODE]] をヘルプストリングに変換\n *\n * @param code [[RESULT_CODE]]\n * @returns registered help string\n */\nexport function toHelpString(code: number): string {\n    const map = ERROR_MESSAGE_MAP();\n    if (map[code]) {\n        return map[code];\n    } else {\n        return `unregistered result code. [code: ${code}]`;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    className,\n    isNil,\n    isString,\n} from '@cdp/core-utils';\nimport {\n    RESULT_CODE,\n    SUCCEEDED,\n    FAILED,\n    toNameString,\n    toHelpString,\n} from './result-code';\n\n/* eslint-disable-next-line @typescript-eslint/unbound-method */\nconst isNumber = Number.isFinite;\n\nconst enum Tag {\n    ERROR  = 'Error',\n    RESULT = 'Result',\n}\n\n/**\n * @en A result holder class. <br>\n *     Derived native `Error` class.\n * @ja 処理結果伝達クラス <br>\n *     ネイティブ `Error` の派生クラス\n */\nexport class Result extends Error {\n\n    /**\n     * constructor\n     *\n     * @param code\n     *  - `en` result code\n     *  - `ja` 結果コード\n     * @param message\n     *  - `en` result info message\n     *  - `ja` 結果情報メッセージ\n     * @param cause\n     *  - `en` low-level error information\n     *  - `ja` 下位のエラー情報\n     */\n    constructor(code?: number, message?: string, cause?: any) {\n        code = isNil(code) ? RESULT_CODE.SUCCESS : isNumber(code) ? Math.trunc(code) : RESULT_CODE.FAIL;\n        super(message || toHelpString(code));\n        let time = isError(cause) ? (cause as Result).time : undefined;\n        isNumber(time as number) || (time = Date.now());\n        const descriptors: PropertyDescriptorMap = {\n            code:  { enumerable: true, value: code  },\n            cause: { enumerable: true, value: cause },\n            time:  { enumerable: true, value: time  },\n        };\n        Object.defineProperties(this, descriptors);\n    }\n\n    /**\n     * @en [[RESULT_CODE]] value.\n     * @ja [[RESULT_CODE]] の値\n     */\n    readonly code!: number;\n\n    /**\n     * @en Stock low-level error information.\n     * @ja 下位のエラー情報を格納\n     */\n    readonly cause: any;\n\n    /**\n     * @en Generated time information.\n     * @ja 生成された時刻情報\n     */\n    readonly time!: number;\n\n    /**\n     * @en Judge succeeded or not.\n     * @ja 成功判定\n     */\n    get isSucceeded(): boolean {\n        return SUCCEEDED(this.code);\n    }\n\n    /**\n     * @en Judge failed or not.\n     * @ja 失敗判定\n     */\n    get isFailed(): boolean {\n        return FAILED(this.code);\n    }\n\n    /**\n     * @en Judge canceled or not.\n     * @ja キャンセルエラー判定\n     */\n    get isCanceled(): boolean {\n        return this.code === RESULT_CODE.ABORT;\n    }\n\n    /**\n     * @en Get formatted [[RESULT_CODE]] name string.\n     * @ja フォーマットされた [[RESULT_CODE]] 名文字列を取得\n     */\n    get codeName(): string {\n        return toNameString(this.code, this.name);\n    }\n\n    /**\n     * @en Get [[RESULT_CODE]] help string.\n     * @ja [[RESULT_CODE]] のヘルプストリングを取得\n     */\n    get help(): string {\n        return toHelpString(this.code);\n    }\n\n    /** @internal */\n    private get [Symbol.toStringTag](): Tag.RESULT {\n        return Tag.RESULT;\n    }\n}\n\nResult.prototype.name = Tag.RESULT;\n\n/** @interna lReturns `true` if `x` is `Error`, `false` otherwise. */\nfunction isError(x: unknown): x is Error {\n    return x instanceof Error || className(x) === Tag.ERROR;\n}\n\n/** Returns `true` if `x` is `Result`, `false` otherwise. */\nexport function isResult(x: unknown): x is Result {\n    return x instanceof Result || className(x) === Tag.RESULT;\n}\n\n/**\n * @en Transfer [[Result]] object\n * @ja [[Result]] オブジェクトに変換\n */\nexport function toResult(o: unknown): Result {\n    if (o instanceof Result) {\n        /* eslint-disable-next-line prefer-const */\n        let { code, cause, time } = o;\n        code = isNil(code) ? RESULT_CODE.SUCCESS : isNumber(code) ? Math.trunc(code) : RESULT_CODE.FAIL;\n        isNumber(time) || (time = Date.now());\n        // Do nothing if already defined\n        Reflect.defineProperty(o, 'code',  { enumerable: true, value: code  });\n        Reflect.defineProperty(o, 'cause', { enumerable: true, value: cause });\n        Reflect.defineProperty(o, 'time',  { enumerable: true, value: time  });\n        return o;\n    } else {\n        const e = Object(o) as Result;\n        const code = isNumber(e.code) ? e.code : o as any;\n        const message = isString(e.message) ? e.message : isString(o) ? o : undefined;\n        const cause = isError(e.cause) ? e.cause : isError(o) ? o : isString(o) ? new Error(o) : o;\n        return new Result(code, message, cause);\n    }\n}\n\n/**\n * @en Create [[Result]] helper\n * @ja [[Result]] オブジェクト構築ヘルパー\n *\n * @param code\n *  - `en` result code\n *  - `ja` 結果コード\n * @param message\n *  - `en` result info message\n *  - `ja` 結果情報メッセージ\n * @param cause\n *  - `en` low-level error information\n *  - `ja` 下位のエラー情報\n */\nexport function makeResult(code: number, message?: string, cause?: any): Result {\n    return new Result(code, message, cause);\n}\n\n/**\n * @en Create canceled [[Result]] helper\n * @ja キャンセル情報格納 [[Result]] オブジェクト構築ヘルパー\n *\n * @param message\n *  - `en` result info message\n *  - `ja` 結果情報メッセージ\n * @param cause\n *  - `en` low-level error information\n *  - `ja` 下位のエラー情報\n */\nexport function makeCanceledResult(message?: string, cause?: any): Result {\n    return new Result(RESULT_CODE.ABORT, message, cause);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n    PlainObject,\n    post,\n    deepEqual,\n    deepCopy,\n    dropUndefined,\n} from '@cdp/core-utils';\nimport { EventPublisher } from '@cdp/event-publisher';\nimport {\n    IStorage,\n    IStorageOptions,\n    IStorageFormatOptions,\n    RegistrySchemaBase,\n    RegistryEvent,\n    RegistryReadOptions,\n    RegistryWriteOptions,\n    RegistrySaveOptions,\n} from './interfaces';\n\n/**\n * @en Registry management class for synchronous Read/Write accessible from any [[IStorage]] object.\n * @ja 任意の [[IStorage]] オブジェクトから同期 Read/Write アクセス可能なレジストリ管理クラス\n *\n * @example <br>\n *\n * ```ts\n * // 1. define registry schema\n * interface Schema extends RegistrySchemaBase {\n *    'common/mode': 'normal' | 'specified';\n *    'common/value': number;\n *    'trade/local': { unit: '円' | '$'; rate: number; };\n *    'trade/check': boolean;\n *    'extra/user': string;\n * }\n *\n * // 2. prepare IStorage instance\n * // ex\n * import { webStorage } from '@cdp/web-storage';\n *\n * // 3. instantiate this class\n * const reg = new Registry<Schema>(webStorage, '@test');\n *\n * // 4. read example\n * const val = reg.read('common/mode'); // 'normal' | 'specified' | null\n *\n * // 5. write example\n * reg.write('common/mode', 'specified');\n * // reg.write('common/mode', 'hoge'); // compile error\n * ```\n */\nexport class Registry<T extends RegistrySchemaBase = any> extends EventPublisher<RegistryEvent<T>> {\n\n    private readonly _storage: IStorage;\n    private readonly _rootKey: string;\n    private readonly _defaultOptions: IStorageFormatOptions;\n    private _store: PlainObject = {};\n\n    /**\n     * constructor\n     *\n     * @param storage\n     *  - `en` Root key for [[IStorage]].\n     *  - `ja` [[IStorage]] に使用するルートキー\n     * @param rootKey\n     *  - `en` Root key for [[IStorage]].\n     *  - `ja` [[IStorage]] に使用するルートキー\n     * @param formatSpace\n     *  - `en` for JSON format space.\n     *  - `ja` JSON フォーマットスペースを指定\n     */\n    constructor(storage: IStorage<any>, rootKey: string, formatSpace?: number) {\n        super();\n        this._storage = storage;\n        this._rootKey = rootKey;\n        this._defaultOptions = { jsonSpace: formatSpace };\n    }\n\n    /**\n     * @en Access to root key.\n     * @ja ルートキーを取得\n     */\n    get rootKey(): string {\n        return this._rootKey;\n    }\n\n    /**\n     * @en Access to [[IStorage]] object.\n     * @ja [[IStorage]] オブジェクトを取得\n     */\n    get storage(): IStorage<any> {\n        return this._storage;\n    }\n\n///////////////////////////////////////////////////////////////////////\n// public methods:\n\n    /**\n     * @en Read persistence data from [[IStorage]]. The data loaded already will be cleared.\n     * @ja [[IStorage]] から永続化したデータを読み込み. すでにキャッシュされているデータは破棄される\n     */\n    public async load(options?: IStorageOptions): Promise<void> {\n        options = options || {};\n        this._store = (await this._storage.getItem(this._rootKey, options)) || {};\n        if (!options.silent) {\n            post(() => this.publish('change', '*'));\n        }\n    }\n\n    /**\n     * @en Persist data to [[IStorage]].\n     * @ja [[IStorage]] にデータを永続化\n     */\n    public async save(options?: RegistrySaveOptions): Promise<void> {\n        const opts: RegistrySaveOptions = { ...this._defaultOptions, ...options };\n        if (!opts.silent) {\n            this.publish('will-save');\n        }\n        await this._storage.setItem(this._rootKey, this._store, opts);\n    }\n\n    /**\n     * @en Read registry value.\n     * @ja レジストリ値の読み取り\n     *\n     * @param key\n     *  - `en` target registry key.\n     *  - `ja` 対象のレジストリキーを指定\n     * @param options\n     *  - `en` read options.\n     *  - `ja` 読み取りオプションを指定\n     */\n    public read<K extends keyof T>(key: K, options?: RegistryReadOptions): T[K] | null {\n        const { field } = options || {};\n        const structure = String(key).split('/');\n        const lastKey = structure.pop() as string;\n\n        let name: string | undefined;\n        let reg = this._targetRoot(field);\n\n        while (name = structure.shift()) { // eslint-disable-line no-cond-assign\n            if (!(name in reg)) {\n                return null;\n            }\n            reg = reg[name];\n        }\n\n        // return deep copy\n        return (null != reg[lastKey]) ? deepCopy(reg[lastKey]) : null;\n    }\n\n    /**\n     * @en Write registry value.\n     * @ja レジストリ値の書き込み\n     *\n     * @param key\n     *  - `en` target registry key.\n     *  - `ja` 対象のレジストリキーを指定\n     * @param value\n     *  - `en` update value. if `null` set to delete.\n     *  - `ja` 更新する値. `null` は削除\n     * @param options\n     *  - `en` write options.\n     *  - `ja` 書き込みオプションを指定\n     */\n    public write<K extends keyof T>(key: K, value: T[K] | null, options?: RegistryWriteOptions): void {\n        const { field, noSave, silent } = options || {};\n        const remove = (null == value);\n        const structure = String(key).split('/');\n        const lastKey = structure.pop() as string;\n\n        let name: string | undefined;\n        let reg = this._targetRoot(field);\n\n        while (name = structure.shift()) { // eslint-disable-line no-cond-assign\n            if (name in reg) {\n                reg = reg[name];\n            } else if (remove) {\n                return; // すでに親キーがないため何もしない\n            } else {\n                reg = reg[name] = {};\n            }\n        }\n\n        const newVal = remove ? null : value;\n        const oldVal = dropUndefined(reg[lastKey]);\n        if (deepEqual(oldVal, newVal)) {\n            return; // 更新なし\n        } else if (remove) {\n            delete reg[lastKey];\n        } else {\n            reg[lastKey] = deepCopy(newVal);\n        }\n\n        if (!noSave) {\n            // no fire notification\n            this._storage.setItem(this._rootKey, this._store, { ...this._defaultOptions, ...options });\n        }\n\n        if (!silent) {\n            post(() => this.publish('change', key, newVal, oldVal));\n        }\n    }\n\n    /**\n     * @en Delete registry key.\n     * @ja レジストリキーの削除\n     *\n     * @param key\n     *  - `en` target registry key.\n     *  - `ja` 対象のレジストリキーを指定\n     * @param options\n     *  - `en` read options.\n     *  - `ja` 書き込みオプションを指定\n     */\n    public delete<K extends keyof T>(key: K, options?: RegistryWriteOptions): void {\n        this.write(key, null, options);\n    }\n\n    /**\n     * @en Clear all registry.\n     * @ja レジストリの全削除\n     *\n     * @param options\n     *  - `en` read options.\n     *  - `ja` 書き込みオプションを指定\n     */\n    public clear(options?: RegistryWriteOptions): void {\n        options = options || {};\n        this._store = {};\n        this._storage.removeItem(this._rootKey, options);\n        if (!options.silent) {\n            this.publish('change', null, null, null);\n        }\n    }\n\n///////////////////////////////////////////////////////////////////////\n// private methods:\n\n    /** get root object */\n    private _targetRoot(field?: string): PlainObject {\n        if (field) {\n            // ensure [field] object.\n            this._store[field] = this._store[field] || {};\n            return this._store[field];\n        } else {\n            return this._store;\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Subscription } from '@cdp/event-publisher';\nimport { _internal } from './internal';\n\n/**\n * @en Event observation state definition.\n * @ja イベント購読状態定義\n */\nexport const enum ObservableState {\n    /** observable ready */\n    ACTIVE   = 'active',\n    /** NOT observed, but property changes are recorded. */\n    SUSEPNDED = 'suspended',\n    /** NOT observed, and not recording property changes. */\n    DISABLED = 'disabled',\n}\n\n/**\n * @en Observable common interface.\n * @ja Observable 共通インターフェイス\n */\nexport interface IObservable {\n    /**\n     * @en Subscrive event(s).\n     * @ja イベント購読設定\n     */\n    on(...args: any[]): Subscription;\n\n    /**\n     * @en Unsubscribe event(s).\n     * @ja イベント購読解除\n     */\n    off(...args: any[]): void;\n\n    /**\n     * @en Suspend or disable the event observation state.\n     * @ja イベント購読状態のサスペンド\n     *\n     * @param noRecord\n     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when [[resume]]() callded. (default)\n     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, [[resume]]() 時に発火する (既定)\n     */\n    suspend(noRecord?: boolean): this;\n\n    /**\n     * @en Resume the event observation state.\n     * @ja イベント購読状態のリジューム\n     */\n    resume(): this;\n\n    /**\n     * @en observation state\n     * @ja 購読可能状態\n     */\n    getObservableState(): ObservableState;\n}\n\n/**\n * @en Check the value-type is [[IObservable]].\n * @ja [[IObservable]] 型であるか判定\n *\n * @param x\n *  - `en` evaluated value\n *  - `ja` 評価する値\n */\nexport function isObservable(x: any): x is IObservable {\n    return Boolean(x && x[_internal]);\n}\n"]}