{"version":3,"sources":["cdp:///@cdp/lib-worker/binary/ssr.ts","cdp:///@cdp/lib-worker/binary/base64.ts","cdp:///@cdp/lib-worker/binary/blob-reader.ts","cdp:///@cdp/lib-worker/binary/converter.ts","cdp:///@cdp/lib-worker/binary/blob-url.ts","cdp:///@cdp/lib-worker/ajax/result-code-defs.ts","cdp:///@cdp/lib-worker/ajax/ssr.ts","cdp:///@cdp/lib-worker/ajax/settings.ts","cdp:///@cdp/lib-worker/ajax/core.ts","cdp:///@cdp/lib-worker/ajax/request.ts","cdp:///@cdp/lib-worker/inline-worker/inine-worker.ts","cdp:///@cdp/lib-worker/inline-worker/thread.ts"],"names":["btoa","safe","globalThis","atob","Blob","FileReader","URL","Base64","encode","src","unescape","encodeURIComponent","decode","encoded","decodeURIComponent","escape","exec","methodName","args","options","cancel","token","onprogress","verify","CancelToken","Promise","resolve","reject","reader","subscription","register","abort","onabort","onerror","error","onload","result","onloadend","unsubscribe","readAsArrayBuffer","blob","readAsDataURL","readAsText","encoding","undefined","queryDataURLContext","dataURL","context","base64","Error","mimeType","test","data","binaryStringToBinary","bytes","array","split","map","c","charCodeAt","Uint8Array","toBinaryString","text","fromBinaryString","blobToDataURL","bufferToDataURL","buffer","binaryToDataURL","binaryToBlob","binary","type","binaryToBase64","binaryToText","binaryToBinaryString","Array","prototype","call","i","String","fromCharCode","join","base64ToBlob","base64ToBinary","textToBlob","textToBinary","textToBase64","dataURLToBlob","dataURLToBuffer","dataURLToBinary","dataURLToBase64","_blobMap","WeakMap","_urlSet","Set","RESULT_CODE","CDP_DECLARE","DECLARE_ERROR_CODE","_FormData","FormData","_Headers","Headers","_AbortController","AbortController","_URLSearchParams","URLSearchParams","_XMLHttpRequest","XMLHttpRequest","_fetch","fetch","_timeout","settings","timeout","value","isNumber","_acceptHeaderMap","json","setupHeaders","headers","method","contentType","dataType","mode","body","username","password","get","delete","set","ensureParamValue","prop","isFunction","toQueryStrings","params","key","Object","keys","push","toAjaxParams","async","ajax","url","controller","opts","assign","signal","originalToken","requested","reason","source","setTimeout","makeResult","ERROR_AJAX_TIMEOUT","toUpperCase","includes","response","ok","ERROR_AJAX_RESPONSE","statusText","ensureDataType","post","resource","xhr","open","forEach","setRequestHeader","send","status","JSON","parse","Worker","InlineWorker","constructor","createWorkerContext","isString","TypeError","className","createObjectURL","toString","super","this","_context","terminate","revokeObjectURL","BlobURL","create","blobs","b","cache","add","clear","has","revoke","base64ToBuffer","base64ToDataURL","base64ToText","binaryToBuffer","blobToBase64","blobToBinary","blobToBuffer","blobToText","bufferToBase64","bufferToBinary","bufferToBlob","bufferToText","dataURLToText","deserialize","cc","restoreNil","toTypedData","fromTypedData","Number","Boolean","fromHexString","hex","x","match","byte","parseInt","serialize","ArrayBuffer","textToBuffer","textToDataURL","thread","executor","worker","promise","ev","preventDefault","onmessage","postMessage","toHexString","reduce","str","padStart"],"mappings":"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","sourcesContent":["import { safe } from '@cdp/core-utils';\n\n/** @internal */ export const btoa       = safe(globalThis.btoa);\n/** @internal */ export const atob       = safe(globalThis.atob);\n/** @internal */ export const Blob       = safe(globalThis.Blob);\n/** @internal */ export const FileReader = safe(globalThis.FileReader);\n/** @internal */ export const URL        = safe(globalThis.URL);\n","import { atob, btoa } from './ssr';\n\n/**\n * @en `base64` utility for independent charactor code.\n * @ja 文字コードに依存しない `base64` ユーティリティ\n */\nexport class Base64 {\n    /**\n     * @en Encode a base-64 encoded string from a binary string.\n     * @ja 文字列を base64 形式でエンコード\n     */\n    public static encode(src: string): string {\n        return btoa(unescape(encodeURIComponent(src)));\n    }\n\n    /**\n     * @en Decodes a string of data which has been encoded using base-64 encoding.\n     * @ja base64 形式でエンコードされたデータの文字列をデコード\n     */\n    public static decode(encoded: string): string {\n        return decodeURIComponent(escape(atob(encoded)));\n    }\n}\n","import { UnknownFunction, verify } from '@cdp/core-utils';\nimport { CancelToken, Cancelable } from '@cdp/promise';\nimport { FileReader } from './ssr';\n\n/** @internal */\ninterface FileReaderArgsMap {\n    readAsArrayBuffer: [Blob];\n    readAsDataURL: [Blob];\n    readAsText: [Blob, string | undefined];\n}\n\n/** @internal */\ninterface FileReaderResultMap {\n    readAsArrayBuffer: ArrayBuffer;\n    readAsDataURL: string;\n    readAsText: string;\n}\n\n/**\n * @en `Blob` read options\n * @ja `Blob` 読み取りオプション\n */\nexport interface BlobReadOptions extends Cancelable {\n    /**\n     * @en Progress callback function.\n     * @ja 進捗コールバック関数\n     *\n     * @param progress\n     *  - `en` worker progress event\n     *  - `ja` worker 進捗イベント\n     */\n    onprogress?: (progress: ProgressEvent) => unknown;\n}\n\n/** @internal execute read blob */\nfunction exec<T extends keyof FileReaderResultMap>(\n    methodName: T,\n    args: FileReaderArgsMap[T],\n    options: BlobReadOptions,\n): Promise<FileReaderResultMap[T]> {\n    type TResult = FileReaderResultMap[T];\n    const { cancel: token, onprogress } = options;\n    token && verify('instanceOf', CancelToken, token);\n    onprogress && verify('typeOf', 'function', onprogress);\n    return new Promise<TResult>((resolve, reject) => {\n        const reader = new FileReader();\n        const subscription = token && token.register(() => {\n            reader.abort();\n        });\n        reader.onabort = reader.onerror = () => {\n            reject(reader.error);\n        };\n        reader.onprogress = onprogress!; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reader.onload = () => {\n            resolve(reader.result as TResult);\n        };\n        reader.onloadend = () => {\n            subscription && subscription.unsubscribe();\n        };\n        (reader[methodName] as UnknownFunction)(...args);\n    }, token);\n}\n\n/**\n * @en Get the `ArrayBuffer` result from `Blob` or `File`.\n * @ja `Blob` または `File` から `ArrayBuffer` を取得\n *\n * @param blob\n *  - `en` specified reading target object.\n *  - `ja` 読み取り対象のオブジェクトを指定\n * @param options\n *  - `en` reading options.\n *  - `ja` 読み取りオプションを指定\n */\nexport function readAsArrayBuffer(blob: Blob, options?: BlobReadOptions): Promise<ArrayBuffer> {\n    return exec('readAsArrayBuffer', [blob], { ...options });\n}\n\n/**\n * @en Get the data-URL string from `Blob` or `File`.\n * @ja `Blob` または `File` から `data-url 文字列を取得\n *\n * @param blob\n *  - `en` specified reading target object.\n *  - `ja` 読み取り対象のオブジェクトを指定\n * @param options\n *  - `en` reading options.\n *  - `ja` 読み取りオプションを指定\n */\nexport function readAsDataURL(blob: Blob, options?: BlobReadOptions): Promise<string> {\n    return exec('readAsDataURL', [blob], { ...options });\n}\n\n/**\n * @en Get the text content string from `Blob` or `File`.\n * @ja `Blob` または `File` からテキスト文字列を取得\n *\n * @param blob\n *  - `en` specified reading target object.\n *  - `ja` 読み取り対象のオブジェクトを指定\n * @param encoding\n *  - `en` encoding string to use for the returned data. default: `utf-8`\n *  - `ja` エンコーディングを指定する文字列 既定: `utf-8`\n * @param options\n *  - `en` reading options.\n *  - `ja` 読み取りオプションを指定\n */\nexport function readAsText(blob: Blob, encoding?: string | null, options?: BlobReadOptions): Promise<string> {\n    return exec('readAsText', [blob, encoding || undefined], { ...options });\n}\n","import {\n    Keys,\n    Types,\n    TypeToKey,\n    toTypedData,\n    fromTypedData,\n    restoreNil,\n} from '@cdp/core-utils';\nimport {\n    Cancelable,\n    checkCanceled as cc,\n} from '@cdp/promise';\nimport { Base64 } from './base64';\nimport {\n    BlobReadOptions,\n    readAsArrayBuffer,\n    readAsDataURL,\n    readAsText,\n} from './blob-reader';\nimport { Blob } from './ssr';\n\n/** @internal */\nconst enum MimeType {\n    BINARY = 'application/octet-stream',\n    TEXT = 'text/plain',\n}\n\n//__________________________________________________________________________________________________//\n\n/** @internal data-URL 属性 */\ninterface DataURLContext {\n    mimeType: string;\n    base64: boolean;\n    data: string;\n}\n\n/**\n * @internal\n * data URI 形式の正規表現\n * 参考: https://developer.mozilla.org/ja/docs/data_URIs\n */\nfunction queryDataURLContext(dataURL: string): DataURLContext {\n    const context = { base64: false } as DataURLContext;\n\n    /**\n     * [match] 1: mime-type\n     *         2: \";base64\" を含むオプション\n     *         3: data 本体\n     */\n    const result = /^data:(.+?\\/.+?)?(;.+?)?,(.*)$/.exec(dataURL);\n    if (null == result) {\n        throw new Error(`Invalid data-URL: ${dataURL}`);\n    }\n\n    context.mimeType = result[1];\n    context.base64 = /;base64/.test(result[2]); // eslint-disable-line @typescript-eslint/prefer-includes\n    context.data = result[3];\n\n    return context;\n}\n\n//__________________________________________________________________________________________________//\n\n/** @internal helper */\nfunction binaryStringToBinary(bytes: string): Uint8Array {\n    const array = bytes.split('').map(c => c.charCodeAt(0));\n    return new Uint8Array(array);\n}\n\n/** @internal helper */\nfunction binaryToBinaryString(binary: Uint8Array): string {\n    return Array.prototype.map.call(binary, (i: number) => String.fromCharCode(i)).join('');\n}\n\n/**\n * @en Convert string to binary-string. (not human readable string)\n * @ja バイナリ文字列に変換\n *\n * @param text\n */\nexport function toBinaryString(text: string): string {\n    return unescape(encodeURIComponent(text));\n}\n\n/**\n * @en Convert string from binary-string.\n * @ja バイナリ文字列から変換\n *\n * @param bytes\n */\nexport function fromBinaryString(bytes: string): string {\n    return decodeURIComponent(escape(bytes));\n}\n\n/**\n * @en Convert binary to hex-string.\n * @ja バイナリを HEX 文字列に変換\n *\n * @param hex\n */\nexport function fromHexString(hex: string): Uint8Array {\n    const x = hex.match(/.{1,2}/g);\n    return new Uint8Array(null != x ? x.map(byte => parseInt(byte, 16)) : []);\n}\n\n/**\n * @en Convert string from hex-string.\n * @ja HEX 文字列からバイナリに変換\n *\n * @param binary\n */\nexport function toHexString(binary: Uint8Array): string {\n    return binary.reduce((str, byte) => str + byte.toString(16).toUpperCase().padStart(2, '0'), '');\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert `Blob` to `ArrayBuffer`.\n * @ja `Blob` から `ArrayBuffer` へ変換\n *\n * @param blob\n *  - `en` `Blob` instance\n *  - `ja` `Blob` インスタンスを指定\n * @param options\n */\nexport function blobToBuffer(blob: Blob, options?: BlobReadOptions): Promise<ArrayBuffer> {\n    return readAsArrayBuffer(blob, options);\n}\n\n/**\n * @en Convert `Blob` to `Uint8Array`.\n * @ja `Blob` から `Uint8Array` へ変換\n *\n * @param blob\n *  - `en` `Blob` instance\n *  - `ja` `Blob` インスタンスを指定\n * @param options\n */\nexport async function blobToBinary(blob: Blob, options?: BlobReadOptions): Promise<Uint8Array> {\n    return new Uint8Array(await readAsArrayBuffer(blob, options));\n}\n\n/**\n * @en Convert `Blob` to data-URL string.\n * @ja `Blob` から data-URL 文字列へ変換\n *\n * @param blob\n *  - `en` `Blob` instance\n *  - `ja` `Blob` インスタンスを指定\n * @param options\n */\nexport function blobToDataURL(blob: Blob, options?: BlobReadOptions): Promise<string> {\n    return readAsDataURL(blob, options);\n}\n\n/**\n * @en Convert `Blob` to text string.\n * @ja `Blob` からテキストへ変換\n *\n * @param blob\n *  - `en` `Blob` instance\n *  - `ja` `Blob` インスタンスを指定\n * @param options\n */\nexport function blobToText(blob: Blob, options?: BlobReadOptions & { encoding?: string | null; }): Promise<string> {\n    const opts = options || {};\n    const { encoding } = opts;\n    return readAsText(blob, encoding, opts);\n}\n\n/**\n * @en Convert `Blob` to Base64 string.\n * @ja `Blob` から Base64 文字列へ変換\n *\n * @param blob\n *  - `en` `Blob` instance\n *  - `ja` `Blob` インスタンスを指定\n * @param options\n */\nexport async function blobToBase64(blob: Blob, options?: BlobReadOptions): Promise<string> {\n    return queryDataURLContext(await readAsDataURL(blob, options)).data;\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert `ArrayBuffer` to `Blob`.\n * @ja `ArrayBuffer` から `Blob` に変換\n *\n * @param buffer\n *  - `en` `ArrayBuffer` instance\n *  - `ja` `ArrayBuffer` インスタンスを指定\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function bufferToBlob(buffer: ArrayBuffer, mimeType: string = MimeType.BINARY): Blob {\n    return new Blob([buffer], { type: mimeType });\n}\n\n/**\n * @en Convert `ArrayBuffer` to `Uint8Array`.\n * @ja `ArrayBuffer` から `Uint8Array` に変換\n *\n * @param buffer\n *  - `en` `ArrayBuffer` instance\n *  - `ja` `ArrayBuffer` インスタンスを指定\n */\nexport function bufferToBinary(buffer: ArrayBuffer): Uint8Array {\n    return new Uint8Array(buffer);\n}\n\n/**\n * @en Convert `ArrayBuffer` to data-URL string.\n * @ja `ArrayBuffer` から data-URL 文字列に変換\n *\n * @param buffer\n *  - `en` `ArrayBuffer` instance\n *  - `ja` `ArrayBuffer` インスタンスを指定\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function bufferToDataURL(buffer: ArrayBuffer, mimeType: string = MimeType.BINARY): string {\n    return binaryToDataURL(new Uint8Array(buffer), mimeType);\n}\n\n/**\n * @en Convert `ArrayBuffer` to Base64 string.\n * @ja `ArrayBuffer` から Base64 文字列に変換\n *\n * @param buffer\n *  - `en` `ArrayBuffer` instance\n *  - `ja` `ArrayBuffer` インスタンスを指定\n */\nexport function bufferToBase64(buffer: ArrayBuffer): string {\n    return binaryToBase64(new Uint8Array(buffer));\n}\n\n/**\n * @en Convert `ArrayBuffer` to text string.\n * @ja `ArrayBuffer` からテキストに変換\n *\n * @param buffer\n *  - `en` `ArrayBuffer` instance\n *  - `ja` `ArrayBuffer` インスタンスを指定\n */\nexport function bufferToText(buffer: ArrayBuffer): string {\n    return binaryToText(new Uint8Array(buffer));\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert `Uint8Array` to `Blob`.\n * @ja `Uint8Array` から `Blob` に変換\n *\n * @param binary\n *  - `en` `Uint8Array` instance\n *  - `ja` `Uint8Array` インスタンスを指定\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function binaryToBlob(binary: Uint8Array, mimeType: string = MimeType.BINARY): Blob {\n    return new Blob([binary], { type: mimeType });\n}\n\n/**\n * @en Convert `Uint8Array` to `ArrayBuffer`.\n * @ja `Uint8Array` から `ArrayBuffer` に変換\n *\n * @param binary\n *  - `en` `Uint8Array` instance\n *  - `ja` `Uint8Array` インスタンスを指定\n */\nexport function binaryToBuffer(binary: Uint8Array): ArrayBuffer {\n    return binary.buffer;\n}\n\n/**\n * @en Convert `Uint8Array` to data-URL string.\n * @ja `Uint8Array` から data-URL 文字列に変換\n *\n * @param binary\n *  - `en` `Uint8Array` instance\n *  - `ja` `Uint8Array` インスタンスを指定\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function binaryToDataURL(binary: Uint8Array, mimeType: string = MimeType.BINARY): string {\n    return `data:${mimeType};base64,${binaryToBase64(binary)}`;\n}\n\n/**\n * @en Convert `Uint8Array` to Base64 string.\n * @ja `Uint8Array` から Base64 文字列に変換\n *\n * @param binary\n *  - `en` `Uint8Array` instance\n *  - `ja` `Uint8Array` インスタンスを指定\n */\nexport function binaryToBase64(binary: Uint8Array): string {\n    return Base64.encode(binaryToText(binary));\n}\n\n/**\n * @en Convert `Uint8Array` to text string.\n * @ja `Uint8Array` から テキストに変換\n *\n * @param binary\n *  - `en` `Uint8Array` instance\n *  - `ja` `Uint8Array` インスタンスを指定\n */\nexport function binaryToText(binary: Uint8Array): string {\n    return fromBinaryString(binaryToBinaryString(binary));\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert Base64 string to `Blob`.\n * @ja Base64 文字列から `Blob` に変換\n *\n * @param base64\n *  - `en` Base64 string data\n *  - `ja` Base64 文字列\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function base64ToBlob(base64: string, mimeType: string = MimeType.BINARY): Blob {\n    return binaryToBlob(base64ToBinary(base64), mimeType);\n}\n\n/**\n * @en Convert Base64 string to `ArrayBuffer`.\n * @ja Base64 文字列から `ArrayBuffer` に変換\n *\n * @param base64\n *  - `en` Base64 string data\n *  - `ja` Base64 文字列\n */\nexport function base64ToBuffer(base64: string): ArrayBuffer {\n    return base64ToBinary(base64).buffer;\n}\n\n/**\n * @en Convert Base64 string to `Uint8Array`.\n * @ja Base64 文字列から `Uint8Array` に変換\n *\n * @param base64\n *  - `en` Base64 string data\n *  - `ja` Base64 文字列\n */\nexport function base64ToBinary(base64: string): Uint8Array {\n    return binaryStringToBinary(toBinaryString(Base64.decode(base64)));\n}\n\n/**\n * @en Convert Base64 string to data-URL string.\n * @ja Base64 文字列から data-URL 文字列に変換\n *\n * @param base64\n *  - `en` Base64 string data\n *  - `ja` Base64 文字列\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function base64ToDataURL(base64: string, mimeType: string = MimeType.BINARY): string {\n    return `data:${mimeType};base64,${base64}`;\n}\n\n/**\n * @en Convert Base64 string to text string.\n * @ja  Base64 文字列から テキストに変換\n *\n * @param base64\n *  - `en` Base64 string data\n *  - `ja` Base64 文字列\n */\nexport function base64ToText(base64: string): string {\n    return Base64.decode(base64);\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert text string to `Blob`.\n * @ja テキストから `Blob` に変換\n *\n * @param text\n *  - `en` text string data\n *  - `ja` テキスト文字列\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function textToBlob(text: string, mimeType: string = MimeType.TEXT): Blob {\n    return new Blob([text], { type: mimeType });\n}\n\n/**\n * @en Convert text string to `ArrayBuffer`.\n * @ja テキストから `ArrayBuffer` に変換\n *\n * @param text\n *  - `en` text string data\n *  - `ja` テキスト文字列\n */\nexport function textToBuffer(text: string): ArrayBuffer {\n    return textToBinary(text).buffer;\n}\n\n/**\n * @en Convert text string to `Uint8Array`.\n * @ja テキストから `Uint8Array` に変換\n *\n * @param text\n *  - `en` text string data\n *  - `ja` テキスト文字列\n */\nexport function textToBinary(text: string): Uint8Array {\n    return binaryStringToBinary(toBinaryString(text));\n}\n\n/**\n * @en Convert text string to data-URL string.\n * @ja テキストから data-URL 文字列に変換\n *\n * @param text\n *  - `en` text string data\n *  - `ja` テキスト文字列\n * @param mimeType\n *  - `en` mime-type string\n *  - `ja` mime-type 文字列\n */\nexport function textToDataURL(text: string, mimeType: string = MimeType.TEXT): string {\n    const base64 = textToBase64(text);\n    return `data:${mimeType};base64,${base64}`;\n}\n\n/**\n * @en Convert text string to Base64 string.\n * @ja テキストから Base64 文字列に変換\n *\n * @param text\n *  - `en` text string data\n *  - `ja` テキスト文字列\n */\nexport function textToBase64(text: string): string {\n    return Base64.encode(text);\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Convert data-URL string to `Blob`.\n * @ja data-URL 文字列から `Blob` に変換\n *\n * @param dataURL\n *  - `en` data-URL string data\n *  - `ja` data-URL 文字列\n */\nexport function dataURLToBlob(dataURL: string): Blob {\n    const context = queryDataURLContext(dataURL);\n    if (context.base64) {\n        return base64ToBlob(context.data, context.mimeType || MimeType.BINARY);\n    } else {\n        return textToBlob(decodeURIComponent(context.data), context.mimeType || MimeType.TEXT);\n    }\n}\n\n/**\n * @en Convert data-URL string to `ArrayBuffer`.\n * @ja data-URL 文字列から `ArrayBuffer` に変換\n *\n * @param dataURL\n *  - `en` data-URL string data\n *  - `ja` data-URL 文字列\n */\nexport function dataURLToBuffer(dataURL: string): ArrayBuffer {\n    return dataURLToBinary(dataURL).buffer;\n}\n\n/**\n * @en Convert data-URL string to `Uint8Array`.\n * @ja data-URL 文字列から `Uint8Array` に変換\n *\n * @param dataURL\n *  - `en` data-URL string data\n *  - `ja` data-URL 文字列\n */\nexport function dataURLToBinary(dataURL: string): Uint8Array {\n    return base64ToBinary(dataURLToBase64(dataURL));\n}\n\n/**\n * @en Convert data-URL string to text string.\n * @ja data-URL 文字列からテキストに変換\n *\n * @param dataURL\n *  - `en` data-URL string data\n *  - `ja` data-URL 文字列\n */\nexport function dataURLToText(dataURL: string): string {\n    return Base64.decode(dataURLToBase64(dataURL));\n}\n\n/**\n * @en Convert data-URL string to Base64 string.\n * @ja data-URL 文字列から Base64 文字列に変換\n *\n * @param dataURL\n *  - `en` data-URL string data\n *  - `ja` data-URL 文字列\n */\nexport function dataURLToBase64(dataURL: string): string {\n    const context = queryDataURLContext(dataURL);\n    if (context.base64) {\n        return context.data;\n    } else {\n        return Base64.encode(decodeURIComponent(context.data));\n    }\n}\n\n//__________________________________________________________________________________________________//\n\n/**\n * @en Serializable data type list.\n * @ja シリアライズ可能なデータ型一覧\n */\nexport interface Serializable {\n    string: string;\n    number: number;\n    boolean: boolean;\n    object: object;\n    buffer: ArrayBuffer;\n    binary: Uint8Array;\n    blob: Blob;\n}\n\nexport type SerializableDataTypes = Types<Serializable>;\nexport type SerializableInputDataTypes = SerializableDataTypes | null | undefined;\nexport type SerializableKeys = Keys<Serializable>;\nexport type SerializableCastable = Omit<Serializable, 'buffer' | 'binary' | 'blob'>;\nexport type SerializableCastableTypes = Types<SerializableCastable>;\nexport type SerializableReturnType<T extends SerializableCastableTypes> = TypeToKey<SerializableCastable, T> extends never ? never : T | null | undefined;\n\n/**\n * @en Deserializable options interface.\n * @ja デシリアライズに使用するオプション\n */\nexport interface DeserializeOptions<T extends Serializable = Serializable, K extends Keys<T> = Keys<T>> extends Cancelable {\n    /** [[SerializableKeys]] */\n    dataType?: K;\n}\n\n/**\n * @en Serialize data.\n * @ja データシリアライズ\n *\n * @param data input\n * @param options blob convert options\n */\nexport async function serialize<T extends SerializableInputDataTypes>(data: T, options?: BlobReadOptions): Promise<string> {\n    const { cancel } = options || {};\n    await cc(cancel);\n    if (null == data) {\n        return String(data);\n    } else if (data instanceof ArrayBuffer) {\n        return bufferToDataURL(data);\n    } else if (data instanceof Uint8Array) {\n        return binaryToDataURL(data);\n    } else if (data instanceof Blob) {\n        return blobToDataURL(data, options);\n    } else {\n        return fromTypedData(data) as string;\n    }\n}\n\n/**\n * @en Deserialize data.\n * @ja データの復元\n *\n * @param value input string or undefined.\n * @param options deserialize options\n */\nexport function deserialize<T extends SerializableCastableTypes = SerializableCastableTypes>(\n    value: string | undefined, options?: DeserializeOptions<Serializable, never>\n): Promise<SerializableReturnType<T>>;\n\n/**\n * @en Deserialize data.\n * @ja データの復元\n *\n * @param value input string or undefined.\n * @param options deserialize options\n */\nexport function deserialize<T extends SerializableKeys>(value: string | undefined, options: DeserializeOptions<Serializable, T>): Promise<Serializable[T] | null | undefined>;\n\nexport async function deserialize(value: string | undefined, options?: DeserializeOptions): Promise<SerializableDataTypes | null | undefined> {\n    const { dataType, cancel } = options || {};\n    await cc(cancel);\n\n    const data = restoreNil(toTypedData(value));\n    switch (dataType) {\n        case 'string':\n            return fromTypedData(data);\n        case 'number':\n            return Number(data);\n        case 'boolean':\n            return Boolean(data);\n        case 'object':\n            return Object(data);\n        case 'buffer':\n            return dataURLToBuffer(fromTypedData(data) as string);\n        case 'binary':\n            return dataURLToBinary(fromTypedData(data) as string);\n        case 'blob':\n            return dataURLToBlob(fromTypedData(data) as string);\n        default:\n            return data;\n    }\n}\n","import { URL } from './ssr';\n\n/** @internal */ const _blobMap = new WeakMap<Blob, string>();\n/** @internal */ const _urlSet  = new Set<string>();\n\n/**\n * @en `Blob URL` utility for automatic memory manegement.\n * @ja メモリ自動管理を行う `Blob URL` ユーティリティ\n */\nexport class BlobURL {\n    /**\n     * @en Create `Blob URL` from instances.\n     * @ja インスタンスを指定して `Blob URL` の構築\n     */\n    public static create(...blobs: Blob[]): void {\n        for (const b of blobs) {\n            const cache = _blobMap.get(b);\n            if (cache) {\n                continue;\n            }\n            const url = URL.createObjectURL(b);\n            _blobMap.set(b, url);\n            _urlSet.add(url);\n        }\n    }\n\n    /**\n     * @en Clear all `Blob URL` cache.\n     * @ja すべての `Blob URL` キャッシュを破棄\n     */\n    public static clear(): void {\n        for (const url of _urlSet) {\n            URL.revokeObjectURL(url);\n        }\n        _urlSet.clear();\n    }\n\n    /**\n     * @en Get `Blob URL` from instance.\n     * @ja インスタンスを指定して `Blob URL` の取得\n     */\n    public static get(blob: Blob): string {\n        const cache = _blobMap.get(blob);\n        if (cache) {\n            return cache;\n        }\n        const url = URL.createObjectURL(blob);\n        _blobMap.set(blob, url);\n        _urlSet.add(url);\n        return url;\n    }\n\n    /**\n     * @en Check `Blob URL` is available from instance.\n     * @ja インスタンスを指定して `Blob URL` が有効化判定\n     */\n    public static has(blob: Blob): boolean {\n        return _blobMap.has(blob);\n    }\n\n    /**\n     * @en Revoke `Blob URL` from instances.\n     * @ja インスタンスを指定して `Blob URL` を無効化\n     */\n    public static revoke(...blobs: Blob[]): void {\n        for (const b of blobs) {\n            const url = _blobMap.get(b);\n            if (url) {\n                URL.revokeObjectURL(url);\n                _blobMap.delete(b);\n                _urlSet.delete(url);\n            }\n        }\n    }\n}\n","/* eslint-disable\n    @typescript-eslint/no-namespace,\n    @typescript-eslint/no-unused-vars,\n    @typescript-eslint/restrict-plus-operands,\n */\n\nnamespace CDP_DECLARE {\n\n    const enum LOCAL_CODE_BASE {\n        AJAX = CDP_KNOWN_MODULE.AJAX * LOCAL_CODE_RANGE_GUIDE.FUNCTION,\n    }\n\n    /**\n     * @en Extends error code definitions.\n     * @ja 拡張通エラーコード定義\n     */\n    export enum RESULT_CODE {\n        AJAX_DECLARE        = RESULT_CODE_BASE.DECLARE,\n        ERROR_AJAX_RESPONSE = DECLARE_ERROR_CODE(RESULT_CODE_BASE.CDP, LOCAL_CODE_BASE.AJAX + 1, 'network error.'),\n        ERROR_AJAX_TIMEOUT  = DECLARE_ERROR_CODE(RESULT_CODE_BASE.CDP, LOCAL_CODE_BASE.AJAX + 2, 'request timeout.'),\n    }\n}\n","import { safe } from '@cdp/core-utils';\n\n/** @internal */ const _FormData        = safe(globalThis.FormData);\n/** @internal */ const _Headers         = safe(globalThis.Headers);\n/** @internal */ const _AbortController = safe(globalThis.AbortController);\n/** @internal */ const _URLSearchParams = safe(globalThis.URLSearchParams);\n/** @internal */ const _XMLHttpRequest  = safe(globalThis.XMLHttpRequest);\n/** @internal */ const _fetch           = safe(globalThis.fetch);\n\n/** @internal */\nexport {\n    _FormData as FormData,\n    _Headers as Headers,\n    _AbortController as AbortController,\n    _URLSearchParams as URLSearchParams,\n    _XMLHttpRequest as XMLHttpRequest,\n    _fetch as fetch,\n};\n","import { isNumber } from '@cdp/core-utils';\n\n/** @internal */ let _timeout: number | undefined;\n\nexport const settings = {\n    get timeout(): number | undefined {\n        return _timeout;\n    },\n    set timeout(value: number | undefined) {\n        _timeout = (isNumber(value) && 0 <= value) ? value : undefined;\n    },\n};\n","import { PlainObject, isFunction } from '@cdp/core-utils';\nimport { CancelToken } from '@cdp/promise';\nimport { RESULT_CODE, makeResult } from '@cdp/result';\nimport { Base64 } from '@cdp/binary';\nimport {\n    AjaxDataTypes,\n    AjaxOptions,\n    AjaxResult,\n} from './interfaces';\nimport {\n    FormData,\n    Headers,\n    AbortController,\n    URLSearchParams,\n    fetch,\n} from './ssr';\nimport { settings } from './settings';\n\n/** @internal */\nexport type AjaxHeaderOptions = Pick<AjaxOptions<AjaxDataTypes>, 'headers' | 'method' | 'contentType' | 'dataType' | 'mode' | 'body' | 'username' | 'password'>;\n\n/** @internal */\nconst _acceptHeaderMap = {\n    text: 'text/plain, text/html, application/xml; q=0.8, text/xml; q=0.8, */*; q=0.01',\n    json: 'application/json, text/javascript, */*; q=0.01',\n};\n\n/**\n * @en Setup `headers` from options parameter.\n * @ja オプションから `headers` を設定\n *\n * @internal\n */\nexport function setupHeaders(options: AjaxHeaderOptions): Headers {\n    const headers = new Headers(options.headers);\n    const { method, contentType, dataType, mode, body, username, password } = options;\n\n    // Content-Type\n    if ('POST' === method || 'PUT' === method || 'PATCH' === method) {\n        /*\n         * fetch() の場合, FormData を自動解釈するため, 指定がある場合は削除\n         * https://stackoverflow.com/questions/35192841/fetch-post-with-multipart-form-data\n         * https://muffinman.io/uploading-files-using-fetch-multipart-form-data/\n         */\n        if (headers.get('Content-Type') && body instanceof FormData) {\n            headers.delete('Content-Type');\n        } else if (!headers.get('Content-Type')) {\n            if (null == contentType && 'json' === dataType as AjaxDataTypes) {\n                headers.set('Content-Type', 'application/json; charset=UTF-8');\n            } else if (null != contentType) {\n                headers.set('Content-Type', contentType);\n            }\n        }\n    }\n\n    // Accept\n    if (!headers.get('Accept')) {\n        headers.set('Accept', _acceptHeaderMap[dataType as AjaxDataTypes] || '*/*');\n    }\n\n    // X-Requested-With\n    if ('cors' !== mode && !headers.get('X-Requested-With')) {\n        headers.set('X-Requested-With', 'XMLHttpRequest');\n    }\n\n    // Basic Authorization\n    if (null != username && !headers.get('Authorization')) {\n        headers.set('Authorization', `Basic ${Base64.encode(`${username}:${password || ''}`)}`);\n    }\n\n    return headers;\n}\n\n/** @internal ensure string value */\nfunction ensureParamValue(prop: unknown): string {\n    const value = isFunction(prop) ? prop() : prop;\n    return undefined !== value ? String(value) : '';\n}\n\n/**\n * @en Convert `PlainObject` to query strings.\n * @ja `PlainObject` をクエリストリングに変換\n */\nexport function toQueryStrings(data: PlainObject): string {\n    const params: string[] = [];\n    for (const key of Object.keys(data)) {\n        const value = ensureParamValue(data[key]);\n        if (value) {\n            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n        }\n    }\n    return params.join('&');\n}\n\n/**\n * @en Convert `PlainObject` to Ajax parameters object.\n * @ja `PlainObject` を Ajax パラメータオブジェクトに変換\n */\nexport function toAjaxParams(data: PlainObject): Record<string, string> {\n    const params: Record<string, string> = {};\n    for (const key of Object.keys(data)) {\n        const value = ensureParamValue(data[key]);\n        if (value) {\n            params[key] = value;\n        }\n    }\n    return params;\n}\n\n/**\n * @en Perform an asynchronous HTTP (Ajax) request.\n * @ja HTTP (Ajax)リクエストの送信\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param options\n *  - `en` Ajax request settings.\n *  - `ja` Ajaxリクエスト設定\n */\nasync function ajax<T extends AjaxDataTypes | object = 'response'>(url: string, options?: AjaxOptions<T>): Promise<AjaxResult<T>> {\n    const controller = new AbortController();\n    const abort = (): void => controller.abort();\n\n    const opts = Object.assign({\n        method: 'GET',\n        dataType: 'response',\n        timeout: settings.timeout,\n    }, options, {\n        signal: controller.signal, // force override\n    });\n\n    const { cancel: originalToken, timeout } = opts;\n\n    // cancellation\n    if (originalToken) {\n        if (originalToken.requested) {\n            throw originalToken.reason;\n        }\n        originalToken.register(abort);\n    }\n\n    const source = CancelToken.source(originalToken as CancelToken);\n    const { token } = source;\n    token.register(abort);\n\n    // timeout\n    if (timeout) {\n        setTimeout(() => source.cancel(makeResult(RESULT_CODE.ERROR_AJAX_TIMEOUT, 'request timeout')), timeout);\n    }\n\n    // normalize\n    opts.method = opts.method.toUpperCase();\n\n    // header\n    opts.headers = setupHeaders(opts);\n\n    // parse param\n    const { method, data, dataType } = opts;\n    if (null != data) {\n        if (('GET' === method || 'HEAD' === method) && !url.includes('?')) {\n            url += `?${toQueryStrings(data)}`;\n        } else if (null == opts.body) {\n            opts.body = new URLSearchParams(toAjaxParams(data));\n        }\n    }\n\n    // execute\n    const response = await Promise.resolve(fetch(url, opts), token);\n    if ('response' === dataType) {\n        return response as AjaxResult<T>;\n    } else if (!response.ok) {\n        throw makeResult(RESULT_CODE.ERROR_AJAX_RESPONSE, response.statusText, response);\n    } else {\n        return Promise.resolve(response[dataType as Exclude<AjaxDataTypes, 'response'>](), token);\n    }\n}\n\najax.settings = settings;\n\nexport { ajax };\n","import { PlainObject } from '@cdp/core-utils';\nimport { RESULT_CODE, makeResult } from '@cdp/result';\nimport {\n    AjaxDataTypes,\n    AjaxOptions,\n    AjaxRequestOptions,\n    AjaxResult,\n} from './interfaces';\nimport {\n    ajax,\n    toQueryStrings,\n    setupHeaders,\n} from './core';\nimport { XMLHttpRequest } from './ssr';\n\n/** @internal */\nfunction ensureDataType(dataType?: AjaxDataTypes): AjaxDataTypes {\n    return dataType || 'json';\n}\n\n/**\n * @en `GET` request shortcut.\n * @ja `GET` リクエストショートカット\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n * @param dataType\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーから返される期待するデータの型を指定\n * @param options\n *  - `en` request settings.\n *  - `ja` リクエスト設定\n */\nexport function get<T extends AjaxDataTypes | object = 'json'>(\n    url: string,\n    data?: PlainObject,\n    dataType?: T extends AjaxDataTypes ? T : 'json',\n    options?: AjaxRequestOptions\n): Promise<AjaxResult<T>> {\n    return ajax(url, { ...options, method: 'GET', data, dataType: ensureDataType(dataType) } as AjaxOptions<T>);\n}\n\n/**\n * @en `GET` text request shortcut.\n * @ja `GET` テキストリクエストショートカット\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n * @param options\n *  - `en` request settings.\n *  - `ja` リクエスト設定\n */\nexport function text(url: string, data?: PlainObject, options?: AjaxRequestOptions): Promise<AjaxResult<'text'>> {\n    return get(url, data, 'text', options);\n}\n\n/**\n * @en `GET` JSON request shortcut.\n * @ja `GET` JSON リクエストショートカット\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n * @param options\n *  - `en` request settings.\n *  - `ja` リクエスト設定\n */\nexport function json<T extends 'json' | object = 'json'>(url: string, data?: PlainObject, options?: AjaxRequestOptions): Promise<AjaxResult<T>> {\n    return get<T>(url, data, ('json' as T extends AjaxDataTypes ? T : 'json'), options);\n}\n\n/**\n * @en `GET` Blob request shortcut.\n * @ja `GET` Blob リクエストショートカット\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n * @param options\n *  - `en` request settings.\n *  - `ja` リクエスト設定\n */\nexport function blob(url: string, data?: PlainObject, options?: AjaxRequestOptions): Promise<AjaxResult<'blob'>> {\n    return get(url, data, 'blob', options);\n}\n\n/**\n * @en `POST` request shortcut.\n * @ja `POST` リクエストショートカット\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n * @param dataType\n *  - `en` The type of data that you're expecting back from the server.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param options\n *  - `en` request settings.\n *  - `ja` リクエスト設定\n */\nexport function post<T extends AjaxDataTypes | object = 'json'>(\n    url: string,\n    data: PlainObject,\n    dataType?: T extends AjaxDataTypes ? T : 'json',\n    options?: AjaxRequestOptions\n): Promise<AjaxResult<T>> {\n    return ajax(url, { ...options, method: 'POST', data, dataType: ensureDataType(dataType) } as AjaxOptions<T>);\n}\n\n/**\n * @en Synchronous `GET` request for resource access. <br>\n *     Many browsers have deprecated synchronous XHR support on the main thread entirely.\n * @ja リソース取得のための 同期 `GET` リクエスト. <br>\n *     多くのブラウザではメインスレッドにおける同期的な XHR の対応を全面的に非推奨としているので積極使用は避けること.\n *\n * @param url\n *  - `en` A string containing the URL to which the request is sent.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param dataType\n *  - `en` The type of data that you're expecting back from the server.\n *  - `ja` Ajaxリクエストを送信するURLを指定\n * @param data\n *  - `en` Data to be sent to the server.\n *  - `ja` サーバーに送信されるデータ.\n */\nexport function resource<T extends 'text' | 'json' | object = 'json'>(\n    url: string,\n    dataType?: T extends 'text' | 'json' ? T : 'json',\n    data?: PlainObject,\n): AjaxResult<T> {\n    const xhr = new XMLHttpRequest();\n\n    if (null != data && !url.includes('?')) {\n        url += `?${toQueryStrings(data)}`;\n    }\n\n    // synchronous\n    xhr.open('GET', url, false);\n\n    const type = ensureDataType(dataType);\n    const headers = setupHeaders({ method: 'GET', dataType: type });\n    headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n    });\n\n    xhr.send(null);\n    if (!(200 <= xhr.status && xhr.status < 300)) {\n        throw makeResult(RESULT_CODE.ERROR_AJAX_RESPONSE, xhr.statusText, xhr);\n    }\n\n    return 'json' === type ? JSON.parse(xhr.response) : xhr.response;\n}\n","import {\n    isFunction,\n    isString,\n    className,\n    safe,\n} from '@cdp/core-utils';\n\n/**\n * @en [[InlineWorker]] source type definition.\n * @ja [[InlineWorker]] に指定可能なソース型定義\n */\nexport type InlienWorkerSource = ((self: Worker) => unknown) | string;\n\n/** @internal */ const URL    = safe(globalThis.URL);\n/** @internal */ const Worker = safe(globalThis.Worker);\n/** @internal */ const Blob   = safe(globalThis.Blob);\n\n/** @internal */\nfunction createWorkerContext(src: InlienWorkerSource): string {\n    if (!(isFunction(src) || isString(src))) {\n        throw new TypeError(`${className(src)} is not a function or string.`);\n    }\n    return URL.createObjectURL(new Blob([isFunction(src) ? `(${src.toString()})(self);` : src], { type: 'application/javascript' }));\n}\n\n/**\n * @en Specified `Worker` class which doesn't require a script file.\n * @ja スクリプトファイルを必要としない `Worker` クラス\n */\nexport class InlineWorker extends Worker {\n    /** @internal */\n    private _context: string;\n\n    /**\n     * constructor\n     *\n     * @param src\n     *  - `en` source function or script body.\n     *  - `ja` 実行関数またはスクリプト実体\n     * @param options\n     *  - `en` worker options.\n     *  - `ja` Worker オプション\n     */\n    constructor(src: InlienWorkerSource, options?: WorkerOptions) {\n        const context = createWorkerContext(src);\n        super(context, options);\n        this._context = context;\n    }\n\n///////////////////////////////////////////////////////////////////////\n// override: Worker\n\n    /**\n     * @en For BLOB release. When calling `close ()` in the Worker, call this method as well.\n     * @ja BLOB 解放用. Worker 内で `close()` を呼ぶ場合, 本メソッドもコールすること.\n     */\n    terminate(): void {\n        super.terminate();\n        URL.revokeObjectURL(this._context);\n    }\n}\n","import { UnknownFunction } from '@cdp/core-utils';\nimport { Cancelable, CancelToken } from '@cdp/promise';\nimport { InlineWorker } from './inine-worker';\n\n/**\n * @en Thread options\n * @en スレッドオプション\n */\nexport interface ThreadOptions<T extends UnknownFunction> extends Cancelable, WorkerOptions {\n    args?: Parameters<T>;\n}\n\n/**\n * @en Ensure execution in worker thread.\n * @ja ワーカースレッド内で実行を保証\n *\n * @example <br>\n *\n * ```ts\n * const exec = (arg1: number, arg2: string) => {\n *    // this scope is worker scope. you cannot use closure access.\n *    const param = {...};\n *    const method = (p) => {...};\n *    // you can access arguments from options.\n *    console.log(arg1); // '1'\n *    console.log(arg2); // 'test'\n *    :\n *    return method(param);\n * };\n *\n * const arg1 = 1;\n * const arg2 = 'test';\n * const result = await thread(exec, { args: [arg1, arg2] });\n * ```\n *\n * @param executor\n *  - `en` implement as function scope.\n *  - `ja` 関数スコープとして実装\n * @param options\n *  - `en` thread options\n *  - `ja` スレッドオプション\n */\nexport function thread<T, U>(executor: (...args: U[]) => T | Promise<T>, options?: ThreadOptions<typeof executor>): Promise<T> {\n    const { cancel: originalToken, args } = Object.assign({ args: [] }, options);\n\n    // already cancel\n    if (originalToken?.requested) {\n        throw originalToken.reason;\n    }\n\n    const exec = `(self => {\n        self.addEventListener('message', async ({ data }) => {\n            try {\n                const result = await (${executor.toString()})(...data);\n                self.postMessage(result);\n            } catch (e) {\n                setTimeout(function() { throw e; });\n            }\n        });\n    })(self);`;\n\n    const worker = new InlineWorker(exec, options);\n\n    const abort = (): void => worker.terminate();\n    originalToken?.register(abort);\n    const { token } = CancelToken.source(originalToken as CancelToken);\n\n    const promise = new Promise((resolve, reject) => {\n        worker.onerror = ev => {\n            ev.preventDefault();\n            reject(ev);\n            worker.terminate();\n        };\n        worker.onmessage = ev => {\n            resolve(ev.data);\n            worker.terminate();\n        };\n    }, token);\n\n    worker.postMessage(args);\n\n    return promise as Promise<T>;\n}\n"]}